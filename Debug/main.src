; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optspeed -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\main.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME0",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME1"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME2"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME2",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",8
.DEFINE "baudRate"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "dataBits"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stopBits"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "parity"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flowcontrol"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "eir"
.VALUE 7
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",15
.DEFINE "fs"
.VALUE 0
.CLASS 8
.TYPE 46
.ENDEF
.DEFINE "id"
.VALUE 3
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "attr"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stat"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "sclust"
.VALUE 7
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "objsize"
.VALUE 11
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",36
.DEFINE "obj"
.VALUE 0
.CLASS 8
.TAG "NONAME4"
.TYPE 8
.ENDEF
.DEFINE "flag"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "err"
.VALUE 16
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fptr"
.VALUE 17
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "clust"
.VALUE 21
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "sect"
.VALUE 25
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir_sect"
.VALUE 29
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir_ptr"
.VALUE 33
.CLASS 8
.TYPE 46
.ENDEF
.ENDREC "NONAME5"
;    1	//Copyright HeathenUK 2023, others' copyrights (Envenomator, Dean Belfield, etc.) unaffected.
;    2	
;    3	#include <stdio.h>
;    4	#include <stdlib.h>
;    5	#include <ctype.h>
;    6	#include <stdint.h>
;    7	#include <string.h>
;    8	#include <eZ80.h>
;    9	#include <defines.h>
;   10	#include "mos-interface.h"
;   11	#include "vdp.h"
;   12	
;   13	typedef struct {
;   14		
;   15		uint16_t bmp_width;
;   16		uint16_t bmp_height;
;   17		uint8_t  bmp_bitdepth;
;   18		
;   19		uint32_t pixels_offset;
;   20		uint32_t bmp_size;
;   21		uint32_t main_header_size;
;   22		
;   23		uint32_t compression;
;   24		
;   25		uint32_t redBitField;
;   26		uint32_t greenBitField;
;   27		uint32_t blueBitField;
;   28		uint32_t alphaBitField;
;   29		
;   30		uint32_t color_table_size;
;   31		char color_table[1024];
;   32		
;   33		int8_t red_pos;
;   34		int8_t green_pos;
;   35		int8_t blue_pos;
;   36		int8_t alpha_pos;
;   37		
;   38		uint16_t row_padding;
;   39		uint16_t non_pad_row;
;   40		
;   41	} bmp_info;
.BEGREC "NONAME6",1073
.DEFINE "bmp_width"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "bmp_height"
.VALUE 2
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "bmp_bitdepth"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pixels_offset"
.VALUE 5
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "bmp_size"
.VALUE 9
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "main_header_size"
.VALUE 13
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "compression"
.VALUE 17
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "redBitField"
.VALUE 21
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "greenBitField"
.VALUE 25
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "blueBitField"
.VALUE 29
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "alphaBitField"
.VALUE 33
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "color_table_size"
.VALUE 37
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "color_table"
.VALUE 41
.CLASS 8
.DIM 1024
.TYPE 98
.ENDEF
.DEFINE "red_pos"
.VALUE 1065
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "green_pos"
.VALUE 1066
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "blue_pos"
.VALUE 1067
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "alpha_pos"
.VALUE 1068
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "row_padding"
.VALUE 1069
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "non_pad_row"
.VALUE 1071
.CLASS 8
.TYPE 13
.ENDEF
.ENDREC "NONAME6"
;   42	
;   43	extern void write16bit(uint16_t w);
;   44	extern void write24bit(uint24_t w);
;   45	extern void write32bit(uint32_t w);
;   46	
;   47	void delay_secs(UINT16 ticks_end) { //1 sec ticks
_delay_secs:
.DEFINE "_delay_secs"

.VALUE _delay_secs

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "delay_secs",47,"_delay_secs"

.LINE 47

.DEFINE "ticks_end"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

.DEFINE "ticks"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;   48		
;   49		UINT32 ticks = 0;
.LINE 49

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
;   50		ticks_end *= 60;
.LINE 50

	LD.LIS	HL,60
	LD	BC,(IX+%6)
	CALL	__smulu
	LD	(IX+%6),L
	LD	(IX+%7),H
;   51		while(true) {
L_3:
.LINE 51

;   52			
;   53			waitvblank();
.LINE 53

	CALL	_waitvblank
;   54			ticks++;
.LINE 54

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;   55			if(ticks >= ticks_end) break;
.LINE 55

	LD	BC,(IX+%6)
	CALL	__stoiu
	LD	BC,HL
	XOR	A,A
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	CALL	__lcmpu
	JR	C,L_3
;   56			
;   57		}
;   58		
;   59	}
.LINE 59

	LD	SP,IX
	POP	IX
	RET	


;**************************** _delay_secs ***************************
;Name                         Addr/Register   Size   Type
;_waitvblank                         IMPORT  -----   function
;ticks                                 IX-4      4   variable
;ticks_end                             IX+6      2   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "delay_secs",59,"_delay_secs"
;   60	
;   61	int min(int a, int b) {
_min:
.DEFINE "_min"

.VALUE _min

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "min",61,"_min"

.LINE 61

.DEFINE "a"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   62	    if (a > b)
.LINE 62

	LD	BC,(IX+%6)
	LD	HL,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JP	P,L__3
	JP	PE,L_6
	JR	L__4
L__3:
	JP	PO,L_6
L__4:
;   63	        return b;
.LINE 63

	LD	HL,(IX+%9)
	JR	L_7
L_6:
;   64	    return a;
.LINE 64

	LD	HL,(IX+%6)
;   65	}
L_7:
.LINE 65

	LD	SP,IX
	POP	IX
	RET	


;**************************** _min ***************************
;Name                         Addr/Register   Size   Type
;b                                     IX+9      3   parameter
;a                                     IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "min",65,"_min"
;   66	
;   67	int max(int a, int b) {
_max:
.DEFINE "_max"

.VALUE _max

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "max",67,"_max"

.LINE 67

.DEFINE "a"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   68	    if (a > b)
.LINE 68

	LD	BC,(IX+%6)
	LD	HL,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JP	P,L__7
	JP	PE,L_9
	JR	L__8
L__7:
	JP	PO,L_9
L__8:
;   69	        return a;
.LINE 69

	LD	HL,(IX+%6)
	JR	L_10
L_9:
;   70	    return b;
.LINE 70

	LD	HL,(IX+%9)
;   71	}
L_10:
.LINE 71

	LD	SP,IX
	POP	IX
	RET	


;**************************** _max ***************************
;Name                         Addr/Register   Size   Type
;b                                     IX+9      3   parameter
;a                                     IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "max",71,"_max"
;   72	
;   73	void flip(uint32_t * framebuffer, int width, int height) {
_flip:
.DEFINE "_flip"

.VALUE _flip

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "flip",73,"_flip"

.LINE 73

.DEFINE "framebuffer"

.CLASS 65

.VALUE 6

.TYPE 47

.ENDEF

.DEFINE "width"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE 12

.TYPE 4

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "row_buffer"

.CLASS 65

.VALUE -5

.TYPE 47

.ENDEF

.DEFINE "row_size"

.CLASS 65

.VALUE -8

.TYPE 4

.ENDEF

.DEFINE "top_row"

.CLASS 65

.VALUE -11

.TYPE 47

.ENDEF

.DEFINE "bottom_row"

.CLASS 65

.VALUE -14

.TYPE 47

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF1
	LD	SP,HL
;   74	    uint16_t y;
;   75	    uint32_t * row_buffer = (uint32_t * ) malloc(sizeof(uint32_t) * width);
.LINE 75

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	LD	(IX+%FFFFFFF1),A
	CALL	_malloc
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	LD	(IX+%FFFFFFFB),HL
;   76	    int row_size = width * sizeof(uint32_t);
.LINE 76

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	(IX+%FFFFFFF8),HL
;   77	
;   78	    for (y = 0; y < height / 2; y++) {
.LINE 78

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_14
L_12:
;   79	        uint32_t * top_row = framebuffer + y * width;
.LINE 79

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF5),HL
;   80	        uint32_t * bottom_row = framebuffer + (height - y - 1) * width;
.LINE 80

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	DEC	HL
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF2),HL
;   81	
;   82	        memcpy(row_buffer, top_row, row_size);
.LINE 82

	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	LD	(IX+%FFFFFFF1),A
	CALL	_memcpy
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	POP	BC
	POP	BC
;   83	        memcpy(top_row, bottom_row, row_size);
.LINE 83

	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF2)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	(IX+%FFFFFFF1),A
	CALL	_memcpy
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	POP	BC
	POP	BC
;   84	        memcpy(bottom_row, row_buffer, row_size);
.LINE 84

	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF2)
	PUSH	BC
	LD	(IX+%FFFFFFF1),A
	CALL	_memcpy
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	POP	BC
	POP	BC
	LD	HL,(IX+%FFFFFFFE)
	INC	HL
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;   85	    }
L_14:
.LINE 85

	LD	BC,2
	LD	HL,(IX+%C)
	CALL	__idivs
	LD	DE,HL
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	OR	A,A
	SBC	HL,DE
	JP	M,L__11
	JP	PE,L_12
	JR	L__12
L__11:
	JP	PO,L_12
L__12:
;   86	
;   87	    free(row_buffer);
.LINE 87

	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	CALL	_free
	POP	BC
;   88	}
.LINE 88

	LD	SP,IX
	POP	IX
	RET	


;**************************** _flip ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_memcpy                             IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;bottom_row                           IX-14      3   variable
;top_row                              IX-11      3   variable
;row_size                              IX-8      3   variable
;row_buffer                            IX-5      3   variable
;y                                     IX-2      2   variable
;height                               IX+12      3   parameter
;width                                 IX+9      3   parameter
;framebuffer                           IX+6      3   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "flip",88,"_flip"
;   89	
;   90	void twiddle_buffer(char* buffer, int width, int height) {
_twiddle_buffer:
.DEFINE "_twiddle_buffer"

.VALUE _twiddle_buffer

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "twiddle_buffer",90,"_twiddle_buffer"

.LINE 90

.DEFINE "buffer"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "width"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE 12

.TYPE 4

.ENDEF

.DEFINE "col"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "tempRow"

.CLASS 65

.VALUE -6

.TYPE 34

.ENDEF

.DEFINE "oppositeRowPtr"

.CLASS 65

.VALUE -9

.TYPE 34

.ENDEF

.DEFINE "rowPtr"

.CLASS 65

.VALUE -12

.TYPE 34

.ENDEF

.DEFINE "row"

.CLASS 65

.VALUE -15

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE4
	LD	SP,HL
;   91	    int row, col;
;   92	    char* rowPtr;
;   93		char* oppositeRowPtr;
;   94		char* tempRow = (char*)malloc(width * 4);
.LINE 94

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	LD	(IX+%FFFFFFE4),A
	CALL	_malloc
	LD	A,(IX+%FFFFFFE4)
	POP	BC
	LD	(IX+%FFFFFFFA),HL
;   95	
;   96	    //Iterate over each row
;   97	    for (row = 0; row < height / 2; row++) {
.LINE 97

	LD	BC,0
	LD	(IX+%FFFFFFF1),BC
	JR	L_24
L_22:
;   98	        rowPtr = buffer + row * width * 4;
.LINE 98

	LD	HL,(IX+%FFFFFFF1)
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF4),HL
;   99	        oppositeRowPtr = buffer + (height - row - 1) * width * 4;
.LINE 99

	LD	BC,(IX+%FFFFFFF1)
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	DEC	HL
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF7),HL
;  100	
;  101	        //Swap bytes within each row (BGRA to RGBA)
;  102	        for (col = 0; col < width; col++) {
.LINE 102

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_21
L_19:
;  103	            tempRow[col * 4] = oppositeRowPtr[col * 4 + 2]; // R
.LINE 103

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,(IX+%FFFFFFF7)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	LD	A,(IY+%2)
	LD	(HL),A
;  104	            tempRow[col * 4 + 1] = oppositeRowPtr[col * 4 + 1]; // G
.LINE 104

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,DE
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	INC	HL
	LD	A,(IY+%1)
	LD	(HL),A
;  105	            tempRow[col * 4 + 2] = oppositeRowPtr[col * 4]; // B
.LINE 105

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	INC	HL
	INC	HL
	LD	A,(IY)
	LD	(HL),A
;  106	            tempRow[col * 4 + 3] = oppositeRowPtr[col * 4 + 3]; // A
.LINE 106

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	IY,HL
	LD	(IX+%FFFFFFEE),HL	; spill
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFEB),HL	; spill
	LD	BC,DE
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%FFFFFFEB)	; unspill
	LD	A,(HL)
	LD	(IY+%3),A
;  107	
;  108	            oppositeRowPtr[col * 4] = rowPtr[col * 4 + 2]; // R
.LINE 108

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,DE
	LD	A,(IY+%2)
	LD	(HL),A
;  109	            oppositeRowPtr[col * 4 + 1] = rowPtr[col * 4 + 1]; // G
.LINE 109

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,DE
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	INC	HL
	LD	A,(IY+%1)
	LD	(HL),A
;  110	            oppositeRowPtr[col * 4 + 2] = rowPtr[col * 4]; // B
.LINE 110

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,DE
	INC	HL
	INC	HL
	LD	A,(IY)
	LD	(HL),A
;  111	            oppositeRowPtr[col * 4 + 3] = rowPtr[col * 4 + 3]; // A
.LINE 111

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,BC
	LD	IY,HL
	LD	(IX+%FFFFFFEE),HL	; spill
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFE8),HL	; spill
	LD	BC,DE
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%FFFFFFE8)	; unspill
	LD	A,(HL)
	LD	(IY+%3),A
;  112	
;  113	            rowPtr[col * 4] = tempRow[col * 4]; // R
.LINE 113

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	LD	A,(IY)
	LD	(HL),A
;  114	            rowPtr[col * 4 + 1] = tempRow[col * 4 + 1]; // G
.LINE 114

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,DE
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,BC
	INC	HL
	LD	A,(IY+%1)
	LD	(HL),A
;  115	            rowPtr[col * 4 + 2] = tempRow[col * 4 + 2]; // B
.LINE 115

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	INC	HL
	INC	HL
	LD	A,(IY+%2)
	LD	(HL),A
;  116	            rowPtr[col * 4 + 3] = tempRow[col * 4 + 3]; // A
.LINE 116

	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	IY,HL
	LD	(IX+%FFFFFFEE),HL	; spill
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFE5),HL	; spill
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF4)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%FFFFFFE5)	; unspill
	LD	A,(HL)
	LD	(IY+%3),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  117	        }
L_21:
.LINE 117

	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JP	M,L__16
	JP	PE,L_19
	JR	L__17
L__16:
	JP	PO,L_19
L__17:
	LD	BC,(IX+%FFFFFFF1)
	INC	BC
	LD	(IX+%FFFFFFF1),BC
;  118	    }
L_24:
.LINE 118

	LD	BC,2
	LD	HL,(IX+%C)
	CALL	__idivs
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF1)
	OR	A,A
	SBC	HL,BC
	JP	M,L__18
	JP	PE,L_22
	JR	L__19
L__18:
	JP	PO,L_22
L__19:
;  119		free(tempRow);
.LINE 119

	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_free
	POP	BC
;  120	}
.LINE 120

	LD	SP,IX
	POP	IX
	RET	


;**************************** _twiddle_buffer ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;row                                  IX-15      3   variable
;rowPtr                               IX-12      3   variable
;oppositeRowPtr                        IX-9      3   variable
;tempRow                               IX-6      3   variable
;col                                   IX-3      3   variable
;height                               IX+12      3   parameter
;width                                 IX+9      3   parameter
;buffer                                IX+6      3   parameter


; Stack Frame Size: 43 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "twiddle_buffer",120,"_twiddle_buffer"
;  121	
;  122	// void bgra8888_to_rgba2222(char *input, char *output, uint16_t num_pixels) {
;  123	    // 
;  124		// char *input_ptr = input;
;  125	    // char *output_ptr = output;
;  126	
;  127	    // while (num_pixels--) {
;  128	
;  129	        // *output_ptr = CONVR64[input[2] >> 6] + CONVG64[input[1] >> 6] + CONVB64[input[0] >> 6] + CONVA64[input[3] >> 6];
;  130	
;  131	        // input_ptr += 4;
;  132	        // output_ptr++;
;  133			// 
;  134	    // }
;  135	// }
;  136	
;  137	void rgba8888_to_rgba2222(char *input, char *output, size_t num_pixels) {
_rgba8888_to_rgba2222:
.DEFINE "_rgba8888_to_rgba2222"

.VALUE _rgba8888_to_rgba2222

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "rgba8888_to_rgba2222",137,"_rgba8888_to_rgba2222"

.LINE 137

.DEFINE "input"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "output"

.CLASS 65

.VALUE 9

.TYPE 34

.ENDEF

.DEFINE "num_pixels"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "input_ptr"

.CLASS 65

.VALUE -3

.TYPE 34

.ENDEF

.DEFINE "output_ptr"

.CLASS 65

.VALUE -6

.TYPE 34

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "g"

.CLASS 65

.VALUE -8

.TYPE 12

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -9

.TYPE 12

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE -10

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE7
	LD	SP,HL
;  138	    char *input_ptr = input;
.LINE 138

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
;  139	    char *output_ptr = output;
.LINE 139

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFFA),BC
;  140	
;  141	    while (num_pixels--) {
.LINE 141

	JR	L_33
L_34:
;  142	        uint8_t r = *input_ptr++;
.LINE 142

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF3),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFF3)
	LD	A,(HL)
	LD	(IX+%FFFFFFF9),A
;  143			uint8_t g = *input_ptr++;
.LINE 143

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF0),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFF0)
	LD	A,(HL)
	LD	(IX+%FFFFFFF8),A
;  144			uint8_t b = *input_ptr++;
.LINE 144

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFED),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFED)
	LD	A,(HL)
	LD	(IX+%FFFFFFF7),A
;  145	        uint8_t a = *input_ptr++;
.LINE 145

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFEA),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFEA)
	LD	A,(HL)
	LD	(IX+%FFFFFFF6),A
;  146	
;  147	        *output_ptr++ = (r & 0xC0) | ((g & 0xC0) >> 2) | ((b & 0xC0) >> 4) | (a >> 6);
.LINE 147

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFE7),BC
	LD	A,(IX+%FFFFFFF8)
	SRL	A
	SRL	A
	AND	A,%30
	LD	L,A
	LD	A,(IX+%FFFFFFF9)
	AND	A,%C0
	LD	B,A
	LD	A,L
	OR	A,B
	LD	B,A
	LD	A,(IX+%FFFFFFF7)
	SRL	A
	SRL	A
	SRL	A
	SRL	A
	AND	A,%C
	LD	L,A
	LD	A,B
	OR	A,L
	LD	B,A
	LD	A,(IX+%FFFFFFF6)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,B
	OR	A,L
	LD	HL,(IX+%FFFFFFE7)
	LD	(HL),A
	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
;  148	    }
L_33:
.LINE 148

	LD	HL,(IX+%C)
	LD	IY,(IX+%C)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%C),IY
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_34
;  149	}
.LINE 149

	LD	SP,IX
	POP	IX
	RET	


;**************************** _rgba8888_to_rgba2222 ***************************
;Name                         Addr/Register   Size   Type
;a                                    IX-10      1   variable
;b                                     IX-9      1   variable
;g                                     IX-8      1   variable
;r                                     IX-7      1   variable
;output_ptr                            IX-6      3   variable
;input_ptr                             IX-3      3   variable
;num_pixels                           IX+12      3   parameter
;output                                IX+9      3   parameter
;input                                 IX+6      3   parameter


; Stack Frame Size: 40 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "rgba8888_to_rgba2222",149,"_rgba8888_to_rgba2222"
;  150	
;  151	void clear_buffer(uint16_t buffer_id) {
_clear_buffer:
.DEFINE "_clear_buffer"

.VALUE _clear_buffer

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "clear_buffer",151,"_clear_buffer"

.LINE 151

.DEFINE "buffer_id"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  152		
;  153		putch(23);
.LINE 153

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;  154		putch(0);
.LINE 154

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;  155		putch(0xA0);
.LINE 155

	LD	BC,160
	PUSH	BC
	CALL	_putch
	POP	BC
;  156		write16bit(buffer_id);
.LINE 156

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  157		putch(2);	
.LINE 157

	LD	BC,2
	PUSH	BC
	CALL	_putch
	POP	BC
;  158		
;  159	}
.LINE 159

	LD	SP,IX
	POP	IX
	RET	


;**************************** _clear_buffer ***************************
;Name                         Addr/Register   Size   Type
;_write16bit                         IMPORT  -----   function
;_putch                              IMPORT  -----   function
;buffer_id                             IX+6      2   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "clear_buffer",159,"_clear_buffer"
;  160	
;  161	void add_stream_to_buffer(uint16_t buffer_id, char* buffer_content, uint16_t buffer_size) {	
_add_stream_to_buffer:
.DEFINE "_add_stream_to_buffer"

.VALUE _add_stream_to_buffer

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "add_stream_to_buffer",161,"_add_stream_to_buffer"

.LINE 161

.DEFINE "buffer_id"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

.DEFINE "buffer_content"

.CLASS 65

.VALUE 9

.TYPE 34

.ENDEF

.DEFINE "buffer_size"

.CLASS 65

.VALUE 12

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  162	
;  163		putch(23);
.LINE 163

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;  164		putch(0);
.LINE 164

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;  165		putch(0xA0);
.LINE 165

	LD	BC,160
	PUSH	BC
	CALL	_putch
	POP	BC
;  166		write16bit(buffer_id);
.LINE 166

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  167		putch(0);
.LINE 167

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;  168		write16bit(buffer_size);
.LINE 168

	LD	BC,(IX+%C)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  169		
;  170		mos_puts(buffer_content, buffer_size, 0);
.LINE 170

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%C)
	CALL	__stoiu
	PUSH	HL
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	_mos_puts
	POP	BC
	POP	BC
	POP	BC
;  171	
;  172	}
.LINE 172

	LD	SP,IX
	POP	IX
	RET	


;**************************** _add_stream_to_buffer ***************************
;Name                         Addr/Register   Size   Type
;_mos_puts                           IMPORT  -----   function
;_write16bit                         IMPORT  -----   function
;_putch                              IMPORT  -----   function
;buffer_size                          IX+12      2   parameter
;buffer_content                        IX+9      3   parameter
;buffer_id                             IX+6      2   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "add_stream_to_buffer",172,"_add_stream_to_buffer"
;  173	
;  174	void vdp_extended_select(uint16_t buffer_id) {	
_vdp_extended_select:
.DEFINE "_vdp_extended_select"

.VALUE _vdp_extended_select

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vdp_extended_select",174,"_vdp_extended_select"

.LINE 174

.DEFINE "buffer_id"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  175	
;  176		putch(23);
.LINE 176

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;  177		putch(27);
.LINE 177

	LD	BC,27
	PUSH	BC
	CALL	_putch
	POP	BC
;  178		putch(0x20);
.LINE 178

	LD	BC,32
	PUSH	BC
	CALL	_putch
	POP	BC
;  179		write16bit(buffer_id);
.LINE 179

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  180	
;  181	}
.LINE 181

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vdp_extended_select ***************************
;Name                         Addr/Register   Size   Type
;_write16bit                         IMPORT  -----   function
;_putch                              IMPORT  -----   function
;buffer_id                             IX+6      2   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "vdp_extended_select",181,"_vdp_extended_select"
;  182	
;  183	void assign_buffer_to_bitmap(uint16_t buffer_id, uint8_t bitmap_format, uint16_t width, uint16_t height) {
_assign_buffer_to_bitmap:
.DEFINE "_assign_buffer_to_bitmap"

.VALUE _assign_buffer_to_bitmap

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "assign_buffer_to_bitmap",183,"_assign_buffer_to_bitmap"

.LINE 183

.DEFINE "buffer_id"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

.DEFINE "bitmap_format"

.CLASS 65

.VALUE 9

.TYPE 12

.ENDEF

.DEFINE "width"

.CLASS 65

.VALUE 12

.TYPE 13

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE 15

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  184	
;  185		//Consolidate buffer: (if needed) VDU 23, 0, &A0, bufferId; &0C
;  186		
;  187		putch(23);
.LINE 187

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;  188		putch(0);
.LINE 188

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;  189		putch(0xA0);
.LINE 189

	LD	BC,160
	PUSH	BC
	CALL	_putch
	POP	BC
;  190		write16bit(buffer_id);
.LINE 190

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  191		putch(0x0E);
.LINE 191

	LD	BC,14
	PUSH	BC
	CALL	_putch
	POP	BC
;  192		
;  193		//Create bitmap from buffer: VDU 23, 27, &21, bufferId; format, width; height;
;  194		
;  195		putch(23);
.LINE 195

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;  196		putch(27);
.LINE 196

	LD	BC,27
	PUSH	BC
	CALL	_putch
	POP	BC
;  197		putch(0x21);
.LINE 197

	LD	BC,33
	PUSH	BC
	CALL	_putch
	POP	BC
;  198		write16bit(buffer_id);
.LINE 198

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  199		putch(bitmap_format);
.LINE 199

	LD	A,(IX+%9)
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;  200		write16bit(width);
.LINE 200

	LD	BC,(IX+%C)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  201		write16bit(height);
.LINE 201

	LD	BC,(IX+%F)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  202		
;  203	}
.LINE 203

	LD	SP,IX
	POP	IX
	RET	


;**************************** _assign_buffer_to_bitmap ***************************
;Name                         Addr/Register   Size   Type
;_write16bit                         IMPORT  -----   function
;_putch                              IMPORT  -----   function
;height                               IX+15      2   parameter
;width                                IX+12      2   parameter
;bitmap_format                         IX+9      1   parameter
;buffer_id                             IX+6      2   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "assign_buffer_to_bitmap",203,"_assign_buffer_to_bitmap"
;  204	
;  205	void reorder(char *arr, uint16_t length) {
_reorder:
.DEFINE "_reorder"

.VALUE _reorder

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "reorder",205,"_reorder"

.LINE 205

.DEFINE "arr"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "length"

.CLASS 65

.VALUE 9

.TYPE 13

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "temp"

.CLASS 65

.VALUE -3

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
;  206	    uint16_t i;
;  207		for (i = 0; i < length; i += 4) {
.LINE 207

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_43
L_41:
;  208	        if (i + 2 < length) {
.LINE 208

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	DE,HL
	INC	DE
	INC	DE
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JP	P,L__29
	JP	PE,L_42
	JR	L__30
L__29:
	JP	PO,L_42
L__30:
;  209	            uint8_t temp = arr[i];
.LINE 209

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFFA),HL
	LD	A,(HL)
	LD	(IX+%FFFFFFFD),A
;  210	            arr[i] = arr[i + 2];
.LINE 210

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	A,(IY+%2)
	LD	(HL),A
;  211	            arr[i + 2] = temp;
.LINE 211

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	INC	HL
	INC	HL
	LD	A,(IX+%FFFFFFFD)
	LD	(HL),A
;  212	        }
;  213	    }
L_42:
.LINE 213

	LD	IY,(IX+%FFFFFFFE)
	LEA	HL,IY+%4
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
L_43:
	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_41
;  214	}
.LINE 214

	LD	SP,IX
	POP	IX
	RET	


;**************************** _reorder ***************************
;Name                         Addr/Register   Size   Type
;temp                                  IX-3      1   variable
;i                                     IX-2      2   variable
;length                                IX+9      2   parameter
;arr                                   IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "reorder",214,"_reorder"
;  215	
;  216	void reorder_and_insert(char *arr, uint16_t length, char **new_arr, uint16_t *new_length, char insert_value) {
_reorder_and_insert:
.DEFINE "_reorder_and_insert"

.VALUE _reorder_and_insert

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "reorder_and_insert",216,"_reorder_and_insert"

.LINE 216

.DEFINE "arr"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "length"

.CLASS 65

.VALUE 9

.TYPE 13

.ENDEF

.DEFINE "new_arr"

.CLASS 65

.VALUE 12

.TYPE 290

.ENDEF

.DEFINE "new_length"

.CLASS 65

.VALUE 15

.TYPE 45

.ENDEF

.DEFINE "insert_value"

.CLASS 65

.VALUE 18

.TYPE 2

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "j"

.CLASS 65

.VALUE -4

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFED
	LD	SP,HL
;  217	
;  218		uint16_t i, j = 0;
.LINE 218

	LD	(IX+%FFFFFFFC),%0
	LD	(IX+%FFFFFFFD),%0
;  219	    *new_length = (length / 3) * 4 + (length % 3);
.LINE 219

	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,3
	CALL	__idivs
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,3
	CALL	__irems
	ADD	HL,DE
	LD	BC,HL
	LD	HL,(IX+%F)
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  220	    *new_arr = (char *) malloc(*new_length * sizeof(char));
.LINE 220

	LD	HL,(IX+%F)
	LD	BC,(HL)
	CALL	__stoiu
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	IY,(IX+%C)
	LD	(IY),HL
;  221	
;  222	    for (i = 0; i < length; i += 3) {
.LINE 222

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_55
L_53:
;  223	        
;  224	        (*new_arr)[j] = (i + 2 < length) ? arr[i + 2] : 0;
.LINE 224

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	DE,HL
	INC	DE
	INC	DE
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JP	P,L__35
	JP	PE,L_47
	JR	L__36
L__35:
	JP	PO,L_47
L__36:
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	(IX+%FFFFFFF9),HL
	JR	L_48
L_47:
	LD	BC,0
	LD	(IX+%FFFFFFF9),BC
L_48:
	LD	IY,(IX+%C)
	LD	BC,(IX+%FFFFFFFC)
	CALL	__stoiu
	LD	BC,(IY)
	ADD	HL,BC
	LD	(IX+%FFFFFFF3),HL
	LD	A,(IX+%FFFFFFF9)
	LD	HL,(IX+%FFFFFFF3)
	LD	(HL),A
;  225	        (*new_arr)[j + 1] = (i + 1 < length) ? arr[i + 1] : 0;
.LINE 225

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	DE,HL
	INC	DE
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JP	P,L__37
	JP	PE,L_51
	JR	L__38
L__37:
	JP	PO,L_51
L__38:
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	INC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	(IX+%FFFFFFF6),HL
	JR	L_52
L_51:
	LD	BC,0
	LD	(IX+%FFFFFFF6),BC
L_52:
	LD	A,(IX+%FFFFFFF6)
	LD	HL,(IX+%FFFFFFF3)
	INC	HL
	LD	(HL),A
;  226	        (*new_arr)[j + 2] = arr[i];
.LINE 226

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%C)
	LD	(IX+%FFFFFFED),HL	; spill
	LD	BC,(IX+%FFFFFFFC)
	CALL	__stoiu
	LD	(IX+%FFFFFFF0),HL	; spill
	LD	HL,(IX+%FFFFFFED)	; unspill
	LD	BC,(HL)
	LD	HL,(IX+%FFFFFFF0)	; unspill
	ADD	HL,BC
	INC	HL
	INC	HL
	LD	A,(IY)
	LD	(HL),A
;  227	        
;  228	        (*new_arr)[j + 3] = 0xFF;
.LINE 228

	LD	IY,(IX+%C)
	LD	BC,(IX+%FFFFFFFC)
	CALL	__stoiu
	LD	BC,(IY)
	ADD	HL,BC
	LD	IY,HL
	LEA	HL,IY+%3
	LD	(HL),%FF
;  229	
;  230	        j += 4;
.LINE 230

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%4
	LD	(IX+%FFFFFFFC),L
	LD	(IX+%FFFFFFFD),H
	LD	IY,(IX+%FFFFFFFE)
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;  231	    }
L_55:
.LINE 231

	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_53
;  232		
;  233	}
.LINE 233

	LD	SP,IX
	POP	IX
	RET	


;**************************** _reorder_and_insert ***************************
;Name                         Addr/Register   Size   Type
;_malloc                             IMPORT  -----   function
;G_0                                  IX-13      3   variable
;temp49                               IX-10      3   variable
;temp45                                IX-7      3   variable
;j                                     IX-4      2   variable
;i                                     IX-2      2   variable
;insert_value                         IX+18      1   parameter
;new_length                           IX+15      3   parameter
;new_arr                              IX+12      3   parameter
;length                                IX+9      2   parameter
;arr                                   IX+6      3   parameter


; Stack Frame Size: 40 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "reorder_and_insert",233,"_reorder_and_insert"
;  234	
;  235	void bgr888_to_rgba2222(char *input, char *output, size_t num_pixels) {
_bgr888_to_rgba2222:
.DEFINE "_bgr888_to_rgba2222"

.VALUE _bgr888_to_rgba2222

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "bgr888_to_rgba2222",235,"_bgr888_to_rgba2222"

.LINE 235

.DEFINE "input"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "output"

.CLASS 65

.VALUE 9

.TYPE 34

.ENDEF

.DEFINE "num_pixels"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "input_ptr"

.CLASS 65

.VALUE -3

.TYPE 34

.ENDEF

.DEFINE "output_ptr"

.CLASS 65

.VALUE -6

.TYPE 34

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "g"

.CLASS 65

.VALUE -8

.TYPE 12

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -9

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEE
	LD	SP,HL
;  236	    char *input_ptr = input;
.LINE 236

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
;  237	    char *output_ptr = output;
.LINE 237

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFFA),BC
;  238	
;  239	    while (num_pixels--) {
.LINE 239

	JR	L_62
L_63:
;  240	        uint8_t b = *input_ptr++;
.LINE 240

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF4),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFF4)
	LD	A,(HL)
	LD	(IX+%FFFFFFF9),A
;  241	        uint8_t g = *input_ptr++;
.LINE 241

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF1),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFF1)
	LD	A,(HL)
	LD	(IX+%FFFFFFF8),A
;  242	        uint8_t r = *input_ptr++;
.LINE 242

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFEE),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFEE)
	LD	A,(HL)
	LD	(IX+%FFFFFFF7),A
;  243	        uint8_t a = 0xFF; // Alpha channel is always set to max value
;  244	
;  245			// *output_ptr = 0;
;  246			// *output_ptr |= CONVR64[r >> 6];
;  247			// *output_ptr |= CONVG64[g >> 6];
;  248			// *output_ptr |= CONVB64[b >> 6];
;  249			// *output_ptr |= CONVA64[a >> 6];
;  250			// output_ptr++;
;  251			
;  252			*output_ptr = ((r >> 6) & 0x03) | 
;  253	              (((g >> 6) & 0x03) << 2) | 
;  254	              (((b >> 6) & 0x03) << 4) | 
;  255	              (((a >> 6) & 0x03) << 6);	
.LINE 255

	LD	A,(IX+%FFFFFFF8)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	LD	B,A
	LD	A,(IX+%FFFFFFF7)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	LD	C,A
	LD	A,B
	OR	A,C
	LD	B,A
	LD	A,(IX+%FFFFFFF9)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	A,B
	OR	A,C
	OR	A,%C0
	LD	HL,(IX+%FFFFFFFA)
	LD	(HL),A
;  256			output_ptr++;
.LINE 256

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
;  257			
;  258	    }
L_62:
.LINE 258

	LD	HL,(IX+%C)
	LD	IY,(IX+%C)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%C),IY
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_63
;  259	}
.LINE 259

	LD	SP,IX
	POP	IX
	RET	


;**************************** _bgr888_to_rgba2222 ***************************
;Name                         Addr/Register   Size   Type
;r                                     IX-9      1   variable
;g                                     IX-8      1   variable
;b                                     IX-7      1   variable
;output_ptr                            IX-6      3   variable
;input_ptr                             IX-3      3   variable
;num_pixels                           IX+12      3   parameter
;output                                IX+9      3   parameter
;input                                 IX+6      3   parameter


; Stack Frame Size: 33 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "bgr888_to_rgba2222",259,"_bgr888_to_rgba2222"
;  260	
;  261	void bgra8888_to_rgba2222(char *input, char *output, size_t num_pixels) {
_bgra8888_to_rgba2222:
.DEFINE "_bgra8888_to_rgba2222"

.VALUE _bgra8888_to_rgba2222

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "bgra8888_to_rgba2222",261,"_bgra8888_to_rgba2222"

.LINE 261

.DEFINE "input"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "output"

.CLASS 65

.VALUE 9

.TYPE 34

.ENDEF

.DEFINE "num_pixels"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "input_ptr"

.CLASS 65

.VALUE -3

.TYPE 34

.ENDEF

.DEFINE "output_ptr"

.CLASS 65

.VALUE -6

.TYPE 34

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "g"

.CLASS 65

.VALUE -8

.TYPE 12

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -9

.TYPE 12

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE -10

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEA
	LD	SP,HL
;  262	    char *input_ptr = input;
.LINE 262

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
;  263	    char *output_ptr = output;
.LINE 263

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFFA),BC
;  264	
;  265	    while (num_pixels--) {
.LINE 265

	JR	L_71
L_72:
;  266	        uint8_t b = *input_ptr++;
.LINE 266

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF3),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFF3)
	LD	A,(HL)
	LD	(IX+%FFFFFFF9),A
;  267	        uint8_t g = *input_ptr++;
.LINE 267

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF0),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFF0)
	LD	A,(HL)
	LD	(IX+%FFFFFFF8),A
;  268	        uint8_t r = *input_ptr++;
.LINE 268

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFED),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFED)
	LD	A,(HL)
	LD	(IX+%FFFFFFF7),A
;  269	        uint8_t a = *input_ptr++;;
.LINE 269

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFEA),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFEA)
	LD	A,(HL)
	LD	(IX+%FFFFFFF6),A
;  270	
;  271			*output_ptr = ((r >> 6) & 0x03) | 
;  272	              (((g >> 6) & 0x03) << 2) | 
;  273	              (((b >> 6) & 0x03) << 4) | 
;  274	              (((a >> 6) & 0x03) << 6);	
.LINE 274

	LD	A,(IX+%FFFFFFF8)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	LD	B,A
	LD	A,(IX+%FFFFFFF7)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	LD	C,A
	LD	A,B
	OR	A,C
	LD	B,A
	LD	A,(IX+%FFFFFFF9)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	A,B
	OR	A,C
	LD	D,A
	LD	A,(IX+%FFFFFFF6)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	LD	B,%6
	CALL	__bshl
	LD	B,A
	LD	A,D
	OR	A,B
	LD	HL,(IX+%FFFFFFFA)
	LD	(HL),A
;  275			output_ptr++;
.LINE 275

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
;  276			
;  277	    }
L_71:
.LINE 277

	LD	HL,(IX+%C)
	LD	IY,(IX+%C)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%C),IY
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_72
;  278	}
.LINE 278

	LD	SP,IX
	POP	IX
	RET	


;**************************** _bgra8888_to_rgba2222 ***************************
;Name                         Addr/Register   Size   Type
;a                                    IX-10      1   variable
;r                                     IX-9      1   variable
;g                                     IX-8      1   variable
;b                                     IX-7      1   variable
;output_ptr                            IX-6      3   variable
;input_ptr                             IX-3      3   variable
;num_pixels                           IX+12      3   parameter
;output                                IX+9      3   parameter
;input                                 IX+6      3   parameter


; Stack Frame Size: 37 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "bgra8888_to_rgba2222",278,"_bgra8888_to_rgba2222"
;  279	
;  280	void generic8888_to_rgba2222(char *input, char *output, size_t num_pixels, uint8_t width, int8_t red_byte, int8_t green_byte, int8_t blue_byte, int8_t alpha_byte) {
_generic8888_to_rgba2222:
.DEFINE "_generic8888_to_rgba2222"

.VALUE _generic8888_to_rgba2222

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "generic8888_to_rgba2222",280,"_generic8888_to_rgba2222"

.LINE 280

.DEFINE "input"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "output"

.CLASS 65

.VALUE 9

.TYPE 34

.ENDEF

.DEFINE "num_pixels"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "width"

.CLASS 65

.VALUE 15

.TYPE 12

.ENDEF

.DEFINE "red_byte"

.CLASS 65

.VALUE 18

.TYPE 2

.ENDEF

.DEFINE "green_byte"

.CLASS 65

.VALUE 21

.TYPE 2

.ENDEF

.DEFINE "blue_byte"

.CLASS 65

.VALUE 24

.TYPE 2

.ENDEF

.DEFINE "alpha_byte"

.CLASS 65

.VALUE 27

.TYPE 2

.ENDEF

.DEFINE "input_ptr"

.CLASS 65

.VALUE -3

.TYPE 34

.ENDEF

.DEFINE "output_ptr"

.CLASS 65

.VALUE -6

.TYPE 34

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "g"

.CLASS 65

.VALUE -8

.TYPE 12

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -9

.TYPE 12

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE -10

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF3
	LD	SP,HL
;  281	    char *input_ptr = input;
.LINE 281

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
;  282	    char *output_ptr = output;
.LINE 282

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFFA),BC
;  283	
;  284	    while (num_pixels--) {
.LINE 284

	JR	L_80
L_81:
;  285	        uint8_t r = input_ptr[red_byte];
.LINE 285

	LD	A,(IX+%12)
	SEXT	HL
	LD	L,(IX+%12)
	LD	BC,(IX+%FFFFFFFD)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+%FFFFFFF9),A
;  286	        uint8_t g = input_ptr[green_byte];
.LINE 286

	LD	A,(IX+%15)
	SEXT	HL
	LD	L,(IX+%15)
	LD	BC,(IX+%FFFFFFFD)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+%FFFFFFF8),A
;  287	        uint8_t b = input_ptr[blue_byte];
.LINE 287

	LD	A,(IX+%18)
	SEXT	HL
	LD	L,(IX+%18)
	LD	BC,(IX+%FFFFFFFD)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+%FFFFFFF7),A
;  288	        uint8_t a = (alpha_byte < 0) ? 255 : input_ptr[alpha_byte];
.LINE 288

	LD	A,(IX+%1B)
	OR	A,A
	JP	P,L_77
	LD	BC,255
	LD	(IX+%FFFFFFF3),BC
	JR	L_78
L_77:
	LD	A,(IX+%1B)
	SEXT	HL
	LD	L,(IX+%1B)
	LD	BC,(IX+%FFFFFFFD)
	ADD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	(IX+%FFFFFFF3),HL
L_78:
	LD	A,(IX+%FFFFFFF3)
	LD	(IX+%FFFFFFF6),A
;  289	
;  290			*output_ptr = ((r >> 6) & 0x03) | 
;  291	              (((g >> 6) & 0x03) << 2) | 
;  292	              (((b >> 6) & 0x03) << 4) | 
;  293	              (((a >> 6) & 0x03) << 6);	
.LINE 293

	LD	A,(IX+%FFFFFFF8)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	A,(IX+%FFFFFFF9)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	LD	B,A
	LD	A,C
	OR	A,B
	LD	C,A
	LD	A,(IX+%FFFFFFF7)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	B,A
	LD	A,C
	OR	A,B
	LD	D,A
	LD	A,(IX+%FFFFFFF6)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	LD	B,%6
	CALL	__bshl
	LD	B,A
	LD	A,D
	OR	A,B
	LD	HL,(IX+%FFFFFFFA)
	LD	(HL),A
;  294			output_ptr++;
.LINE 294

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
;  295			
;  296			input_ptr += width;
.LINE 296

	LD	A,(IX+%F)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%FFFFFFFD)
	ADD	HL,BC
	LD	(IX+%FFFFFFFD),HL
;  297			
;  298	    }
L_80:
.LINE 298

	LD	HL,(IX+%C)
	LD	IY,(IX+%C)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%C),IY
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_81
;  299	}
.LINE 299

	LD	SP,IX
	POP	IX
	RET	


;**************************** _generic8888_to_rgba2222 ***************************
;Name                         Addr/Register   Size   Type
;temp75                               IX-13      3   variable
;a                                    IX-10      1   variable
;b                                     IX-9      1   variable
;g                                     IX-8      1   variable
;r                                     IX-7      1   variable
;output_ptr                            IX-6      3   variable
;input_ptr                             IX-3      3   variable
;alpha_byte                           IX+27      1   parameter
;blue_byte                            IX+24      1   parameter
;green_byte                           IX+21      1   parameter
;red_byte                             IX+18      1   parameter
;width                                IX+15      1   parameter
;num_pixels                           IX+12      3   parameter
;output                                IX+9      3   parameter
;input                                 IX+6      3   parameter


; Stack Frame Size: 43 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "generic8888_to_rgba2222",299,"_generic8888_to_rgba2222"
;  300	
;  301	void rgbx5551_to_rgba2222(const uint16_t* src, uint8_t* dest, int width) {
_rgbx5551_to_rgba2222:
.DEFINE "_rgbx5551_to_rgba2222"

.VALUE _rgbx5551_to_rgba2222

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "rgbx5551_to_rgba2222",301,"_rgbx5551_to_rgba2222"

.LINE 301

.DEFINE "src"

.CLASS 65

.VALUE 6

.TYPE 205

.ENDEF

.DEFINE "dest"

.CLASS 65

.VALUE 9

.TYPE 44

.ENDEF

.DEFINE "width"

.CLASS 65

.VALUE 12

.TYPE 4

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -2

.TYPE 3

.ENDEF

.DEFINE "pixel"

.CLASS 65

.VALUE -4

.TYPE 13

.ENDEF

.DEFINE "g"

.CLASS 65

.VALUE -5

.TYPE 12

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -6

.TYPE 12

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	DEC	SP
;  302	    
;  303		int16_t i;
;  304		uint8_t r,g,b;
;  305		uint16_t pixel;
;  306		for (i = 0; i < width; i++) {
.LINE 306

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_86
L_84:
;  307	       
;  308	        pixel = src[i];
.LINE 308

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoi
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	BC,(HL)
	LD	(IX+%FFFFFFFC),C
	LD	(IX+%FFFFFFFD),B
;  309	        r = ((pixel >> 10) & 0x1F) << 3;
.LINE 309

	LD	BC,(IX+%FFFFFFFC)
	CALL	__stoiu
	LD	A,%A
	CALL	__ishrs_b
	LD	A,L
	AND	A,%1F
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	(IX+%FFFFFFF9),A
;  310	        g = ((pixel >> 5) & 0x1F) << 3;
.LINE 310

	LD	BC,(IX+%FFFFFFFC)
	CALL	__stoiu
	LD	A,%5
	CALL	__ishrs_b
	LD	A,L
	AND	A,%1F
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	(IX+%FFFFFFFB),A
;  311	        b = (pixel & 0x1F) << 3;
.LINE 311

	LD	A,(IX+%FFFFFFFC)
	AND	A,%1F
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	(IX+%FFFFFFFA),A
;  312	
;  313	        dest[i] = ((r >> 6) & 0x03) | 
;  314	              (((g >> 6) & 0x03) << 2) | 
;  315	              (((b >> 6) & 0x03) << 4) | 
;  316	              0xC0;
.LINE 316

	LD	A,(IX+%FFFFFFFB)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	A,(IX+%FFFFFFF9)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	LD	B,A
	LD	A,C
	OR	A,B
	LD	C,A
	LD	A,(IX+%FFFFFFFA)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	B,A
	LD	A,C
	OR	A,B
	OR	A,%C0
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoi
	LD	BC,(IX+%9)
	ADD	HL,BC
	LD	(HL),A
	LD	HL,(IX+%FFFFFFFE)
	INC	HL
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;  317	    }
L_86:
.LINE 317

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoi
	LD	BC,(IX+%C)
	OR	A,A
	SBC	HL,BC
	JP	M,L__48
	JP	PE,L_84
	JR	L__49
L__48:
	JP	PO,L_84
L__49:
;  318	}
.LINE 318

	LD	SP,IX
	POP	IX
	RET	


;**************************** _rgbx5551_to_rgba2222 ***************************
;Name                         Addr/Register   Size   Type
;r                                     IX-7      1   variable
;b                                     IX-6      1   variable
;g                                     IX-5      1   variable
;pixel                                 IX-4      2   variable
;i                                     IX-2      2   variable
;width                                IX+12      3   parameter
;dest                                  IX+9      3   parameter
;src                                   IX+6      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "rgbx5551_to_rgba2222",318,"_rgbx5551_to_rgba2222"
;  319	
;  320	int8_t getByte(uint32_t bitmask) {
_getByte:
.DEFINE "_getByte"

.VALUE _getByte

.CLASS 2

.TYPE 66

.ENDEF

.BEGFUNC "getByte",320,"_getByte"

.LINE 320

.DEFINE "bitmask"

.CLASS 65

.VALUE 6

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  321	
;  322	    if (bitmask & 0xFF) {
.LINE 322

	UEXT	HL
	LD	L,(IX+%6)
	LD	E,H
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_94
;  323	        return 0;
.LINE 323

	XOR	A,A
	JR	L_96
;  324	    }
;  325	    else if ((bitmask >> 8) & 0xFF) {
L_94:
.LINE 325

	LD	BC,(IX+%7)
	UEXT	HL
	LD	L,C
	LD	E,H
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_92
;  326	        return 1;
.LINE 326

	LD	A,%1
	JR	L_96
;  327	    }
;  328		else if ((bitmask >> 16) & 0xFF) {
L_92:
.LINE 328

	UEXT	HL
	PUSH	HL
	LD	BC,(IX+%7)
	PUSH	BC
	INC	SP
	POP	BC
	INC	SP
	INC	SP
	UEXT	HL
	LD	L,C
	LD	E,H
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_90
;  329	        return 2;
.LINE 329

	LD	A,%2
	JR	L_96
;  330	    }
;  331	    else if ((bitmask >> 24) & 0xFF) {
L_90:
.LINE 331

	LD	A,(IX+%9)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	UEXT	HL
	LD	L,C
	LD	E,H
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_95
;  332	        return 3;
.LINE 332

	LD	A,%3
	JR	L_96
;  333	    }
L_95:
.LINE 333

;  334	
;  335	    return -1;
.LINE 335

	LD	A,%FF
;  336	}
L_96:
.LINE 336

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getByte ***************************
;Name                         Addr/Register   Size   Type
;bitmask                               IX+6      4   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "getByte",336,"_getByte"
;  337	
;  338	// Function to count trailing zeros in a bitmask
;  339	int count_trailing_zeros(unsigned int bitmask) {
_count_trailing_zeros:
.DEFINE "_count_trailing_zeros"

.VALUE _count_trailing_zeros

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "count_trailing_zeros",339,"_count_trailing_zeros"

.LINE 339

.DEFINE "bitmask"

.CLASS 65

.VALUE 6

.TYPE 14

.ENDEF

.DEFINE "count"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
;  340	    int count = 0;
.LINE 340

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
;  341	    while ((bitmask & 1) == 0 && count < 32) {
.LINE 341

	JR	L_99
L_100:
;  342	        bitmask >>= 1;
.LINE 342

	LD	HL,(IX+%6)
	LD	A,%1
	CALL	__ishru_b
	LD	(IX+%6),HL
;  343	        count++;
.LINE 343

	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  344	    }
L_99:
.LINE 344

	LD	A,(IX+%6)
	AND	A,%1
	UEXT	HL
	LD	L,A
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_101
	LD	BC,32
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JP	M,L__58
	JP	PE,L_100
	JR	L__59
L__58:
	JP	PO,L_100
L__59:
L_101:
;  345	    return count;
.LINE 345

	LD	HL,(IX+%FFFFFFFD)
;  346	}
.LINE 346

	LD	SP,IX
	POP	IX
	RET	


;**************************** _count_trailing_zeros ***************************
;Name                         Addr/Register   Size   Type
;count                                 IX-3      3   variable
;bitmask                               IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "count_trailing_zeros",346,"_count_trailing_zeros"
;  347	
;  348	void print_bin(void* value, size_t size) {
_print_bin:
.DEFINE "_print_bin"

.VALUE _print_bin

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "print_bin",348,"_print_bin"

.LINE 348

.DEFINE "value"

.CLASS 65

.VALUE 6

.TYPE 33

.ENDEF

.DEFINE "size"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "j"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
;  349	    
;  350		int i, j;
;  351		unsigned char* bytes = (unsigned char*)value;
;  352		
;  353		if (size == 0) {
.LINE 353

	LD	BC,0
	LD	HL,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_112
;  354	        printf("Error: Invalid size\n");
.LINE 354

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__62
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  355	        return;
.LINE 355

	JR	L_113
;  356	    }
L_112:
.LINE 356

;  357	
;  358	    for (i = size - 1; i >= 0; i--) {
.LINE 358

	LD	BC,(IX+%9)
	DEC	BC
	LD	(IX+%FFFFFFFD),BC
	JR	L_111
L_109:
;  359	        for (j = 7; j >= 0; j--) {
.LINE 359

	LD	BC,7
	LD	(IX+%FFFFFFFA),BC
	JR	L_108
L_106:
;  360	            printf("%d", (bytes[i] >> j) & 1);
.LINE 360

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%6)
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%FFFFFFFA)
	CALL	__ishrs
	LD	A,L
	AND	A,%1
	UEXT	HL
	LD	L,A
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,(IX+%FFFFFFFA)
	DEC	BC
	LD	(IX+%FFFFFFFA),BC
;  361	        }
L_108:
.LINE 361

	LD	BC,0
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JP	P,L__65
	JP	PE,L_106
	JR	L__66
L__65:
	JP	PO,L_106
L__66:
	LD	BC,(IX+%FFFFFFFD)
	DEC	BC
	LD	(IX+%FFFFFFFD),BC
;  362	    }
L_111:
.LINE 362

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JP	P,L__67
	JP	PE,L_109
	JR	L__68
L__67:
	JP	PO,L_109
L__68:
;  363	}
L_113:
.LINE 363

	LD	SP,IX
	POP	IX
	RET	


;**************************** _print_bin ***************************
;Name                         Addr/Register   Size   Type
;__u_itoa                            IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;j                                     IX-6      3   variable
;i                                     IX-3      3   variable
;size                                  IX+9      3   parameter
;value                                 IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "print_bin",363,"_print_bin"
	SEGMENT STRSECT
L__62:
	DB	"Error: Invalid size"
	DB	10,0
	SEGMENT CODE
;  364	
;  365	bmp_info get_info(const char * filename) {
_get_info:
.DEFINE "_get_info"

.VALUE _get_info

.CLASS 2

.TAG "NONAME6"

.TYPE 72

.ENDEF

.BEGFUNC "get_info",365,"_get_info"

.LINE 365

.DEFINE "filename"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "main_header"

.CLASS 65

.VALUE -3

.TYPE 34

.ENDEF

.DEFINE "file"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "redmask"

.CLASS 65

.VALUE -6

.TYPE 13

.ENDEF

.DEFINE "greenmask"

.CLASS 65

.VALUE -8

.TYPE 13

.ENDEF

.DEFINE "bluemask"

.CLASS 65

.VALUE -10

.TYPE 13

.ENDEF

.DEFINE "alphamask"

.CLASS 65

.VALUE -12

.TYPE 13

.ENDEF

.DEFINE "fo"

.CLASS 65

.VALUE -15

.TAG "NONAME5"

.TYPE 40

.ENDEF

.DEFINE "initial_header"

.CLASS 65

.VALUE -33

.DIM 18

.TYPE 98

.ENDEF

.DEFINE "bmp"

.CLASS 65

.VALUE -1106

.TAG "NONAME6"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-1106
	ADD	HL,SP
	LD	SP,HL
;  366	
;  367		uint8_t file;
;  368		FIL * fo;
;  369		bmp_info bmp;
;  370		char initial_header[18];
;  371		char *main_header;
;  372		
;  373		memset(&bmp, 0, sizeof(bmp));	
.LINE 373

	LD	BC,1073
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	HL,IX
	LD	BC,-1106
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  374		
;  375		file = mos_fopen(filename, fa_read);
.LINE 375

	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),A
;  376		fo = (FIL * ) mos_getfil(file);
.LINE 376

	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_getfil
	POP	BC
	LD	(IX+%FFFFFFF1),HL
;  377		
;  378	    if (!file) {
.LINE 378

	LD	A,(IX+%FFFFFFFC)
	OR	A,A
	JR	NZ,L_115
;  379	        printf("Error: could not open %s.\r\n", filename);
.LINE 379

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__71
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__72
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  380	        return bmp;
.LINE 380

	LEA	HL,IX+%6
	LD	DE,(HL)
	LD	HL,IX
	LD	BC,-1106
	ADD	HL,BC
	LD	BC,1073
	LDIR	
	LD	HL,(IX+%6)
	JR	L_132
;  381	    }
L_115:
.LINE 381

;  382	
;  383		mos_fread(file, initial_header, 14 + 4); //14 Bytes for core header, 4 bytes for full header size
.LINE 383

	LD	BC,18
	PUSH	BC
	PEA	IX+%FFFFFFDF
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  384		
;  385		bmp.pixels_offset = * (uint32_t * ) & initial_header[10];
.LINE 385

	LEA	HL,IX+%FFFFFFE9
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1101
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  386	    bmp.main_header_size = * (uint32_t * ) & initial_header[14];
.LINE 386

	LEA	HL,IX+%FFFFFFED
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1093
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  387		
;  388		main_header = malloc(bmp.main_header_size);
.LINE 388

	LD	HL,-1093
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFFD),HL
;  389		
;  390		mos_flseek(file, 14);
.LINE 390

	LD	BC,0
	PUSH	BC
	LD	BC,14
	PUSH	BC
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  391		mos_fread(file, main_header, bmp.main_header_size);
.LINE 391

	LD	HL,-1093
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  392		
;  393		bmp.bmp_width = *(int32_t *) & main_header[4];
.LINE 393

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%4
	LD	BC,(HL)
	LD	HL,-1106
	LD	DE,IX
	ADD	HL,DE
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  394		bmp.bmp_height = *(int32_t *) & main_header[8];
.LINE 394

	LEA	HL,IY+%8
	LD	BC,(HL)
	LD	HL,-1104
	LD	DE,IX
	ADD	HL,DE
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  395		bmp.bmp_bitdepth = *(uint16_t *) & main_header[14];	
.LINE 395

	LEA	HL,IY+%E
	LD	A,(HL)
	LD	HL,-1102
	LD	BC,IX
	ADD	HL,BC
	LD	(HL),A
;  396		bmp.compression = *(uint32_t *) & main_header[16];
.LINE 396

	LEA	HL,IY+%10
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1089
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  397		bmp.color_table_size = * (uint32_t * ) & main_header[32];
.LINE 397

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%20
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1069
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  398	
;  399	    if (bmp.color_table_size == 0 && bmp.bmp_bitdepth == 8) {
.LINE 399

	LD	IY,-1069
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_119
	LD	HL,-1102
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%8
	JR	NZ,L_119
;  400	        bmp.color_table_size = 256;
.LINE 400

	LD	BC,256
	LD	IY,-1069
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),%0
;  401	    }
L_119:
.LINE 401

;  402	
;  403		if (bmp.color_table_size > 0) mos_fread(file, bmp.color_table, bmp.color_table_size * 4);
.LINE 403

	LD	IY,-1069
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	OR	A,A
	SBC	HL,HL
	LD	E,%0
	CALL	__lcmpu
	JR	NC,L_120
	LD	HL,-1069
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	LD	HL,IX
	LD	BC,-1065
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
L_120:
;  404		
;  405		bmp.row_padding = (4 - (bmp.bmp_width * (bmp.bmp_bitdepth / 8)) % 4) % 4;
.LINE 405

	LD	HL,-1106
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1102
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,8
	CALL	__idivs
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,4
	CALL	__irems
	LD	BC,HL
	LD	HL,4
	OR	A,A
	SBC	HL,BC
	LD	BC,4
	CALL	__irems
	LD	(IX+%FFFFFFDB),L
	LD	(IX+%FFFFFFDC),H
;  406		bmp.non_pad_row = bmp.bmp_width * bmp.bmp_bitdepth / 8;
.LINE 406

	LD	HL,-1106
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1102
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,8
	CALL	__idivs
	LD	(IX+%FFFFFFDD),L
	LD	(IX+%FFFFFFDE),H
;  407		
;  408		printf("Debug: BMP is %u x %u x %u, compression type %u, and DIB size %u\r\n", bmp.bmp_width, bmp.bmp_height, bmp.bmp_bitdepth, bmp.compression, bmp.main_header_size);
.LINE 408

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__76
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	HL,-1106
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__77
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	HL,-1104
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__78
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	HL,-1102
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__79
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	IY,-1089
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__80
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	IY,-1093
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__81
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  409	
;  410		if ((bmp.compression == 3) || (bmp.compression == 6) && bmp.main_header_size >= 108) {
.LINE 410

	LD	IY,-1089
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,3
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_130
	LD	IY,-1089
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,6
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_131
	LD	IY,-1093
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,108
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_131
L_130:
;  411			
;  412			if (bmp.bmp_bitdepth == 32) {
.LINE 412

	LD	HL,-1102
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%20
	JR	NZ,L_129
;  413								
;  414				bmp.redBitField = *(uint32_t *) & main_header[40];
.LINE 414

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%28
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1085
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  415				bmp.red_pos = getByte(bmp.redBitField);
.LINE 415

	LD	IY,-1085
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFD7),A
;  416				
;  417				bmp.greenBitField = *(uint32_t *) & main_header[44];
.LINE 417

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%2C
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1081
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  418				bmp.green_pos = getByte(bmp.greenBitField);
.LINE 418

	LD	IY,-1081
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFD8),A
;  419				
;  420				bmp.blueBitField = *(uint32_t *) & main_header[48];
.LINE 420

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%30
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1077
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  421				bmp.blue_pos = getByte(bmp.blueBitField);
.LINE 421

	LD	IY,-1077
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFD9),A
;  422				
;  423				bmp.alphaBitField = *(uint32_t *) & main_header[52];			
.LINE 423

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%34
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1073
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  424				bmp.alpha_pos = getByte(bmp.alphaBitField);
.LINE 424

	LD	IY,-1073
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFDA),A
;  425				
;  426				printf("Red bitfield:   "); print_bin(&bmp.redBitField, sizeof(bmp.redBitField));	printf(" (byte %u in pixel)\r\n", bmp.red_pos);
.LINE 426

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__86
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,4
	PUSH	BC
	LD	HL,IX
	LD	BC,-1085
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_print_bin
	POP	BC
	POP	BC
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__87
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	A,(IX+%FFFFFFD7)
	SEXT	HL
	LD	L,(IX+%FFFFFFD7)
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__88
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  427				printf("Green bitfield: "); print_bin(&bmp.greenBitField, sizeof(bmp.greenBitField));	printf(" (byte %u in pixel)\r\n", bmp.green_pos);
.LINE 427

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__89
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,4
	PUSH	BC
	LD	HL,IX
	LD	BC,-1081
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_print_bin
	POP	BC
	POP	BC
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__90
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	A,(IX+%FFFFFFD8)
	SEXT	HL
	LD	L,(IX+%FFFFFFD8)
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__91
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  428				printf("Blue bitfield:  "); print_bin(&bmp.blueBitField, sizeof(bmp.blueBitField));	printf(" (byte %u in pixel)\r\n", bmp.blue_pos);
.LINE 428

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__92
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,4
	PUSH	BC
	LD	HL,IX
	LD	BC,-1077
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_print_bin
	POP	BC
	POP	BC
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__93
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	A,(IX+%FFFFFFD9)
	SEXT	HL
	LD	L,(IX+%FFFFFFD9)
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__94
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  429	
;  430				if (bmp.alpha_pos == -1) printf("No alpha channel\r\n");
.LINE 430

	LD	A,(IX+%FFFFFFDA)
	CP	A,%FFFFFFFF
	JR	NZ,L_124
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__96
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  431				else { printf("Alpha bitfield: "); print_bin(&bmp.alphaBitField, sizeof(bmp.alphaBitField)); printf(" (byte %u in pixel)\r\n", bmp.alpha_pos); }
.LINE 431

	JR	L_131
L_124:
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__97
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,4
	PUSH	BC
	LD	HL,IX
	LD	BC,-1073
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_print_bin
	POP	BC
	POP	BC
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__98
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	A,(IX+%FFFFFFDA)
	SEXT	HL
	LD	L,(IX+%FFFFFFDA)
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__99
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  432						
;  433			} else if (bmp.bmp_bitdepth == 16) {
.LINE 433

	JR	L_131
L_129:
	LD	HL,-1102
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%10
	JR	NZ,L_131
;  434				
;  435				uint16_t redmask, greenmask, bluemask, alphamask;
;  436				
;  437				bmp.redBitField = *(uint32_t *) & main_header[40];
.LINE 437

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%28
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1085
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  438				redmask = (uint16_t)(bmp.redBitField & 0xFFFF);
.LINE 438

	LD	HL,-1085
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	LD	(IX+%FFFFFFFA),L
	LD	(IX+%FFFFFFFB),H
;  439				
;  440				bmp.greenBitField = *(uint32_t *) & main_header[44];
.LINE 440

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%2C
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1081
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  441				greenmask = (uint16_t)(bmp.greenBitField & 0xFFFF);
.LINE 441

	LD	HL,-1081
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	LD	(IX+%FFFFFFF8),L
	LD	(IX+%FFFFFFF9),H
;  442				
;  443				bmp.blueBitField = *(uint32_t *) & main_header[48];
.LINE 443

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%30
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1077
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  444				bluemask = (uint16_t)(bmp.blueBitField & 0xFFFF);
.LINE 444

	LD	HL,-1077
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	LD	(IX+%FFFFFFF6),L
	LD	(IX+%FFFFFFF7),H
;  445				
;  446				bmp.alphaBitField = *(uint32_t *) & main_header[52];			
.LINE 446

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%34
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1073
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  447				alphamask = (uint16_t)(bmp.alphaBitField & 0xFFFF);
.LINE 447

	LD	HL,-1073
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	LD	(IX+%FFFFFFF4),L
	LD	(IX+%FFFFFFF5),H
;  448				
;  449				printf("Red bitfield:   "); print_bin(&redmask, sizeof(redmask));
.LINE 449

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__101
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,2
	PUSH	BC
	PEA	IX+%FFFFFFFA
	CALL	_print_bin
	POP	BC
	POP	BC
;  450				printf("\r\nGreen bitfield: "); print_bin(&greenmask, sizeof(greenmask));
.LINE 450

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__102
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,2
	PUSH	BC
	PEA	IX+%FFFFFFF8
	CALL	_print_bin
	POP	BC
	POP	BC
;  451				printf("\r\nBlue bitfield:  "); print_bin(&bluemask, sizeof(bluemask));
.LINE 451

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__103
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,2
	PUSH	BC
	PEA	IX+%FFFFFFF6
	CALL	_print_bin
	POP	BC
	POP	BC
;  452	
;  453				if (bmp.alphaBitField == 0) printf("\r\nNo alpha channel\r\n");
.LINE 453

	LD	IY,-1073
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_126
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__105
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  454				else { printf("\r\nAlpha bitfield: "); print_bin(&alphamask, sizeof(alphamask)); printf("\r\n");}		
.LINE 454

	JR	L_131
L_126:
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__106
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,2
	PUSH	BC
	PEA	IX+%FFFFFFF4
	CALL	_print_bin
	POP	BC
	POP	BC
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__107
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  455				
;  456			}
;  457			
;  458			
;  459		}
L_131:
.LINE 459

;  460		
;  461		mos_fclose(file);
.LINE 461

	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  462		return bmp;
.LINE 462

	LEA	HL,IX+%6
	LD	DE,(HL)
	LD	HL,IX
	LD	BC,-1106
	ADD	HL,BC
	LD	BC,1073
	LDIR	
	LD	HL,(IX+%6)
;  463	
;  464	}
L_132:
.LINE 464

	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_info ***************************
;Name                         Addr/Register   Size   Type
;_mos_fclose                         IMPORT  -----   function
;__u_uitoa                           IMPORT  -----   function
;___print_fmt                        IMPORT     19   variable
;_mos_flseek                         IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;_mos_fread                          IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_mos_getfil                         IMPORT  -----   function
;_mos_fopen                          IMPORT  -----   function
;_memset                             IMPORT  -----   function
;bmp                                IX-1106   1073   variable
;initial_header                       IX-33     18   variable
;fo                                   IX-15      3   variable
;alphamask                            IX-12      2   variable
;bluemask                             IX-10      2   variable
;greenmask                             IX-8      2   variable
;redmask                               IX-6      2   variable
;file                                  IX-4      1   variable
;main_header                           IX-3      3   variable
;filename                              IX+9      3   parameter


; Stack Frame Size: 1118 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "get_info",464,"_get_info"
	SEGMENT STRSECT
L__71:
	DB	"Error: could not open "
	DB	0
L__72:
	DB	"."
	DB	13,10,0
L__76:
	DB	"Debug: BMP is "
	DB	0
L__77:
	DB	" x "
	DB	0
L__78:
	DB	" x "
	DB	0
L__79:
	DB	", compression type "
	DB	0
L__80:
	DB	", and DIB size "
	DB	0
L__81:
	DB	13,10,0
L__86:
	DB	"Red bitfield:   "
	DB	0
L__87:
	DB	" (byte "
	DB	0
L__88:
	DB	" in pixel)"
	DB	13,10,0
L__89:
	DB	"Green bitfield: "
	DB	0
L__90:
	DB	" (byte "
	DB	0
L__91:
	DB	" in pixel)"
	DB	13,10,0
L__92:
	DB	"Blue bitfield:  "
	DB	0
L__93:
	DB	" (byte "
	DB	0
L__94:
	DB	" in pixel)"
	DB	13,10,0
L__96:
	DB	"No alpha channel"
	DB	13,10,0
L__97:
	DB	"Alpha bitfield: "
	DB	0
L__98:
	DB	" (byte "
	DB	0
L__99:
	DB	" in pixel)"
	DB	13,10,0
L__101:
	DB	"Red bitfield:   "
	DB	0
L__102:
	DB	13,10
	DB	"Green bitfield: "
	DB	0
L__103:
	DB	13,10
	DB	"Blue bitfield:  "
	DB	0
L__105:
	DB	13,10
	DB	"No alpha channel"
	DB	13,10,0
L__106:
	DB	13,10
	DB	"Alpha bitfield: "
	DB	0
L__107:
	DB	13,10,0
	SEGMENT CODE
;  465	
;  466	bmp_info load_bmp_clean(const char * filename, UINT8 slot) {
_load_bmp_clean:
.DEFINE "_load_bmp_clean"

.VALUE _load_bmp_clean

.CLASS 2

.TAG "NONAME6"

.TYPE 72

.ENDEF

.BEGFUNC "load_bmp_clean",466,"_load_bmp_clean"

.LINE 466

.DEFINE "filename"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "slot"

.CLASS 65

.VALUE 12

.TYPE 12

.ENDEF

.DEFINE "file"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "main_header"

.CLASS 65

.VALUE -4

.TYPE 34

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -6

.TYPE 3

.ENDEF

.DEFINE "row_rgba2222"

.CLASS 65

.VALUE -9

.TYPE 34

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -11

.TYPE 3

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -13

.TYPE 3

.ENDEF

.DEFINE "fo"

.CLASS 65

.VALUE -16

.TAG "NONAME5"

.TYPE 40

.ENDEF

.DEFINE "src"

.CLASS 65

.VALUE -19

.TYPE 34

.ENDEF

.DEFINE "index"

.CLASS 65

.VALUE -20

.TYPE 12

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -21

.TYPE 12

.ENDEF

.DEFINE "g"

.CLASS 65

.VALUE -22

.TYPE 12

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -23

.TYPE 12

.ENDEF

.DEFINE "src"

.CLASS 65

.VALUE -26

.TYPE 34

.ENDEF

.DEFINE "initial_header"

.CLASS 65

.VALUE -44

.DIM 18

.TYPE 98

.ENDEF

.DEFINE "bmp"

.CLASS 65

.VALUE -1117

.TAG "NONAME6"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-1135
	ADD	HL,SP
	LD	SP,HL
;  467		
;  468		uint8_t file;
;  469		FIL * fo;
;  470		bmp_info bmp;
;  471		char initial_header[18];
;  472		char *main_header;
;  473		char * row_rgba2222;
;  474		int16_t y = 0;
;  475		
;  476		memset(&bmp, 0, sizeof(bmp));	
.LINE 476

	LD	BC,1073
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	HL,IX
	LD	BC,-1117
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  477		
;  478		file = mos_fopen(filename, fa_read);
.LINE 478

	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFF),A
;  479		fo = (FIL * ) mos_getfil(file);
.LINE 479

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_getfil
	POP	BC
	LD	(IX+%FFFFFFF0),HL
;  480		
;  481	    if (!file) {
.LINE 481

	LD	A,(IX+%FFFFFFFF)
	OR	A,A
	JR	NZ,L_134
;  482	        printf("Error: could not open %s.\r\n", filename);
.LINE 482

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__110
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__111
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  483	        return bmp;
.LINE 483

	LEA	HL,IX+%6
	LD	DE,(HL)
	LD	HL,IX
	LD	BC,-1117
	ADD	HL,BC
	LD	BC,1073
	LDIR	
	LD	HL,(IX+%6)
	JR	L_176
;  484	    }
L_134:
.LINE 484

;  485	
;  486		mos_fread(file, initial_header, 14 + 4); //14 Bytes for core header, 4 bytes for full header size
.LINE 486

	LD	BC,18
	PUSH	BC
	PEA	IX+%FFFFFFD4
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  487		
;  488		bmp.pixels_offset = * (uint32_t * ) & initial_header[10];
.LINE 488

	LEA	HL,IX+%FFFFFFDE
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1112
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  489	    bmp.main_header_size = * (uint32_t * ) & initial_header[14];
.LINE 489

	LEA	HL,IX+%FFFFFFE2
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1104
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  490		
;  491		main_header = malloc(bmp.main_header_size);
.LINE 491

	LD	HL,-1104
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFFC),HL
;  492		
;  493		mos_flseek(file, 14);
.LINE 493

	LD	BC,0
	PUSH	BC
	LD	BC,14
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  494		mos_fread(file, main_header, bmp.main_header_size);
.LINE 494

	LD	HL,-1104
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  495		
;  496		bmp.bmp_width = *(int32_t *) & main_header[4];
.LINE 496

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%4
	LD	BC,(HL)
	LD	HL,-1117
	LD	DE,IX
	ADD	HL,DE
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  497		bmp.bmp_height = *(int32_t *) & main_header[8];
.LINE 497

	LEA	HL,IY+%8
	LD	BC,(HL)
	LD	HL,-1115
	LD	DE,IX
	ADD	HL,DE
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  498		bmp.bmp_bitdepth = *(uint16_t *) & main_header[14];	
.LINE 498

	LEA	HL,IY+%E
	LD	A,(HL)
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	(HL),A
;  499		bmp.compression = *(uint32_t *) & main_header[16];
.LINE 499

	LEA	HL,IY+%10
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1100
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  500		bmp.color_table_size = * (uint32_t * ) & main_header[32];
.LINE 500

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%20
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1080
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  501	
;  502	    if (bmp.color_table_size == 0 && bmp.bmp_bitdepth == 8) {
.LINE 502

	LD	IY,-1080
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_138
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%8
	JR	NZ,L_138
;  503	        bmp.color_table_size = 256;
.LINE 503

	LD	BC,256
	LD	IY,-1080
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),%0
;  504	    }
L_138:
.LINE 504

;  505	
;  506		if (bmp.color_table_size > 0) mos_fread(file, bmp.color_table, bmp.color_table_size * 4);
.LINE 506

	LD	IY,-1080
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	OR	A,A
	SBC	HL,HL
	LD	E,%0
	CALL	__lcmpu
	JR	NC,L_139
	LD	HL,-1080
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	LD	HL,IX
	LD	BC,-1076
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
L_139:
;  507		
;  508		bmp.row_padding = (4 - (bmp.bmp_width * (bmp.bmp_bitdepth / 8)) % 4) % 4;
.LINE 508

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,8
	CALL	__idivs
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,4
	CALL	__irems
	LD	BC,HL
	LD	HL,4
	OR	A,A
	SBC	HL,BC
	LD	BC,4
	CALL	__irems
	LD	(IX+%FFFFFFD0),L
	LD	(IX+%FFFFFFD1),H
;  509		bmp.non_pad_row = bmp.bmp_width * bmp.bmp_bitdepth / 8;
.LINE 509

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,8
	CALL	__idivs
	LD	(IX+%FFFFFFD2),L
	LD	(IX+%FFFFFFD3),H
;  510		row_rgba2222 = (char * ) malloc(bmp.bmp_width);
.LINE 510

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFF7),HL
;  511		
;  512		if ((bmp.compression != 0) && (bmp.compression != 3)) {
.LINE 512

	LD	IY,-1100
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_174
	LD	IY,-1100
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,3
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_174
;  513			printf("Non standard BMP compression, exiting.\r\n");
.LINE 513

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__117
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  514			return bmp;
.LINE 514

	LEA	HL,IX+%6
	LD	DE,(HL)
	LD	HL,IX
	LD	BC,-1117
	ADD	HL,BC
	LD	BC,1073
	LDIR	
	LD	HL,(IX+%6)
	JR	L_176
;  515		}
L_174:
.LINE 515

;  516		
;  517		if ((bmp.compression == 3) || (bmp.compression == 6) && bmp.main_header_size >= 108) {
.LINE 517

	LD	IY,-1100
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,3
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_172
	LD	IY,-1100
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,6
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_173
	LD	IY,-1104
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,108
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_173
L_172:
;  518			
;  519			if (bmp.bmp_bitdepth == 16) {
.LINE 519

	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%10
	JR	NZ,L_151
;  520				
;  521				printf("16-bit BMP files not supported, use 8-bit (small), 24-bit (fast) or 32-bit (alpha-enabled).\r\n");
.LINE 521

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__122
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  522				return bmp;
.LINE 522

	LEA	HL,IX+%6
	LD	DE,(HL)
	LD	HL,IX
	LD	BC,-1117
	ADD	HL,BC
	LD	BC,1073
	LDIR	
	LD	HL,(IX+%6)
	JR	L_176
;  523	
;  524			} else if (bmp.bmp_bitdepth == 32) {
L_151:
.LINE 524

	LD	HL,-1113
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%20
	JR	NZ,L_175
;  525						
;  526				char * src;
;  527				
;  528				bmp.redBitField = *(uint32_t *) & main_header[40];
.LINE 528

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%28
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1096
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  529				bmp.red_pos = getByte(bmp.redBitField);
.LINE 529

	LD	IY,-1096
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFCC),A
;  530				bmp.greenBitField = *(uint32_t *) & main_header[44];
.LINE 530

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%2C
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1092
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  531				bmp.green_pos = getByte(bmp.greenBitField);
.LINE 531

	LD	IY,-1092
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFCD),A
;  532				bmp.blueBitField = *(uint32_t *) & main_header[48];
.LINE 532

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%30
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1088
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  533				bmp.blue_pos = getByte(bmp.blueBitField);
.LINE 533

	LD	IY,-1088
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFCE),A
;  534				bmp.alphaBitField = *(uint32_t *) & main_header[52];			
.LINE 534

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%34
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1084
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  535				bmp.alpha_pos = getByte(bmp.alphaBitField);
.LINE 535

	LD	IY,-1084
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFCF),A
;  536				
;  537			    src = (char * ) malloc(bmp.bmp_width * bmp.bmp_bitdepth / 8);
.LINE 537

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,8
	CALL	__idivs
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFED),HL
;  538				mos_flseek(file, bmp.pixels_offset + ((bmp.bmp_height - 1) * (bmp.non_pad_row + bmp.row_padding)));
.LINE 538

	LD	HL,-1115
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	DEC	DE
	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,BC
	LD	BC,-1135	; spill
	CALL	__istix
	LD	BC,(IX+%FFFFFFD0)
	CALL	__stoiu
	LD	BC,-1135	; unspill
	PUSH	HL
	CALL	__ildix
	LD	BC,HL
	POP	HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,HL
	CALL	__itol
	LD	IY,-1112
	LD	DE,IX
	ADD	IY,DE
	LD	HL,(IY)
	LD	E,(IY+%3)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  539				clear_buffer(slot);
.LINE 539

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_clear_buffer
	POP	BC
;  540	
;  541				for (y = bmp.bmp_height - 1; y >= 0; y--) {
.LINE 541

	LD	HL,-1115
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	DEC	HL
	LD	(IX+%FFFFFFFA),L
	LD	(IX+%FFFFFFFB),H
	JR	L_147
L_145:
;  542	
;  543					//printf("Row: %u\r\n",y);
;  544					mos_fread(file, src, bmp.non_pad_row);
.LINE 544

	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	PUSH	HL
	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  545					generic8888_to_rgba2222(src, row_rgba2222,bmp.bmp_width,bmp.bmp_bitdepth / 8,bmp.red_pos,bmp.green_pos,bmp.blue_pos,bmp.alpha_pos);
.LINE 545

	LD	C,(IX+%FFFFFFCF)
	LD	B,%0
	PUSH	BC
	LD	C,(IX+%FFFFFFCE)
	PUSH	BC
	LD	C,(IX+%FFFFFFCD)
	PUSH	BC
	LD	C,(IX+%FFFFFFCC)
	PUSH	BC
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,8
	CALL	__idivs
	LD	C,L
	LD	B,%0
	PUSH	BC
	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	PUSH	HL
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	CALL	_generic8888_to_rgba2222
	LD	IY,24
	ADD	IY,SP
	LD	SP,IY
;  546					add_stream_to_buffer(slot,row_rgba2222,bmp.bmp_width);
.LINE 546

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_add_stream_to_buffer
	POP	BC
	POP	BC
	POP	BC
;  547					mos_flseek(file, fo -> fptr - ((bmp.non_pad_row * 2) + bmp.row_padding));
.LINE 547

	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	ADD	HL,HL
	LD	DE,HL
	LD	BC,(IX+%FFFFFFD0)
	CALL	__stoiu
	ADD	HL,DE
	LD	BC,HL
	CALL	__itol
	LD	IY,(IX+%FFFFFFF0)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	CALL	__lsub
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
	LD	HL,(IX+%FFFFFFFA)
	DEC	HL
	LD	(IX+%FFFFFFFA),L
	LD	(IX+%FFFFFFFB),H
;  548	
;  549				}
L_147:
.LINE 549

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC.SIS	HL,BC
	JP	P,L_145
;  550				free(src);
.LINE 550

	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	CALL	_free
	POP	BC
;  551				
;  552			}
;  553			
;  554		} else if (bmp.compression == 0) {
.LINE 554

	JR	L_175
L_173:
	LD	IY,-1100
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_175
;  555	
;  556			if (bmp.bmp_bitdepth == 16) {
.LINE 556

	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%10
	JR	NZ,L_163
;  557				
;  558				printf("16-bit BMP files not supported, use 8-bit (small), 24-bit (fast) or 32-bit (alpha-enabled).\r\n");
.LINE 558

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__127
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  559				return bmp;
.LINE 559

	LEA	HL,IX+%6
	LD	DE,(HL)
	LD	HL,IX
	LD	BC,-1117
	ADD	HL,BC
	LD	BC,1073
	LDIR	
	LD	HL,(IX+%6)
	JR	L_176
;  560				
;  561			} else if (bmp.bmp_bitdepth == 8) {
L_163:
.LINE 561

	LD	HL,-1113
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%8
	JR	NZ,L_170
;  562				
;  563				int16_t x,y;
;  564				uint8_t index, b, g, r;
;  565	
;  566				mos_flseek(file, bmp.pixels_offset + ((bmp.bmp_height - 1) * (bmp.non_pad_row + bmp.row_padding)));
.LINE 566

	LD	HL,-1115
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	DEC	DE
	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,BC
	LD	BC,-1132	; spill
	CALL	__istix
	LD	BC,(IX+%FFFFFFD0)
	CALL	__stoiu
	LD	BC,-1132	; unspill
	PUSH	HL
	CALL	__ildix
	LD	BC,HL
	POP	HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,HL
	CALL	__itol
	LD	IY,-1112
	LD	DE,IX
	ADD	IY,DE
	LD	HL,(IY)
	LD	E,(IY+%3)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  567				clear_buffer(slot);
.LINE 567

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_clear_buffer
	POP	BC
;  568				
;  569				for (y = bmp.bmp_height - 1; y >= 0; y--) {
.LINE 569

	LD	HL,-1115
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	DEC	HL
	LD	(IX+%FFFFFFF3),L
	LD	(IX+%FFFFFFF4),H
	JR	L_160
L_158:
;  570					for (x = 0; x < bmp.bmp_width; x++) {
.LINE 570

	LD	(IX+%FFFFFFF5),%0
	LD	(IX+%FFFFFFF6),%0
	JR	L_156
L_154:
;  571	
;  572						index = (char) mos_fgetc(file);
.LINE 572

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fgetc
	POP	BC
	LD	(IX+%FFFFFFEC),A
;  573						b = bmp.color_table[index * 4];
.LINE 573

	LD	IY,IX
	LD	BC,-1076
	ADD	IY,BC
	LD	HL,-1123
	LD	BC,IX
	ADD	HL,BC
	LD	(HL),IY
	LD	A,(IX+%FFFFFFEC)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	IY,-1123
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	ADD	HL,BC
	LD	IY,-1120
	LD	BC,IX
	ADD	IY,BC
	LD	(IY),HL
	LD	HL,-1120
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	LD	A,(HL)
	LD	(IX+%FFFFFFEB),A
;  574						g = bmp.color_table[index * 4 + 1];
.LINE 574

	LD	HL,-1120
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFEA),A
;  575						r = bmp.color_table[index * 4 + 2];
.LINE 575

	LD	HL,-1120
	LD	BC,IX
	ADD	HL,BC
	LD	IY,(HL)
	LEA	HL,IY+%2
	LD	A,(HL)
	LD	(IX+%FFFFFFE9),A
;  576						
;  577						row_rgba2222[x] = 	(((r >> 6) & 0x03) | 
;  578											(((g >> 6) & 0x03) << 2) | 
;  579											(((b >> 6) & 0x03) << 4) | 
;  580											0xC0);
.LINE 580

	LD	A,(IX+%FFFFFFEA)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	LD	B,A
	LD	A,(IX+%FFFFFFE9)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	LD	C,A
	LD	A,B
	OR	A,C
	LD	B,A
	LD	A,(IX+%FFFFFFEB)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	A,B
	OR	A,C
	OR	A,%C0
	LD	BC,(IX+%FFFFFFF5)
	CALL	__stoi
	LD	BC,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	(HL),A
	LD	HL,(IX+%FFFFFFF5)
	INC	HL
	LD	(IX+%FFFFFFF5),L
	LD	(IX+%FFFFFFF6),H
;  581						
;  582	
;  583					}
L_156:
.LINE 583

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	LD	BC,(IX+%FFFFFFF5)
	CALL	__stoi
	OR	A,A
	SBC	HL,DE
	JP	M,L__133
	JP	PE,L_154
	JR	L__134
L__133:
	JP	PO,L_154
L__134:
;  584					
;  585					add_stream_to_buffer(slot,row_rgba2222,bmp.bmp_width);
.LINE 585

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_add_stream_to_buffer
	POP	BC
	POP	BC
	POP	BC
;  586					mos_flseek(file, fo -> fptr - ((bmp.non_pad_row * 2) + bmp.row_padding));
.LINE 586

	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	ADD	HL,HL
	LD	DE,HL
	LD	BC,(IX+%FFFFFFD0)
	CALL	__stoiu
	ADD	HL,DE
	LD	BC,HL
	CALL	__itol
	LD	IY,(IX+%FFFFFFF0)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	CALL	__lsub
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
	LD	HL,(IX+%FFFFFFF3)
	DEC	HL
	LD	(IX+%FFFFFFF3),L
	LD	(IX+%FFFFFFF4),H
;  587	
;  588				}
L_160:
.LINE 588

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFF3)
	OR	A,A
	SBC.SIS	HL,BC
	JP	P,L__135
	JP	PE,L_158
	JR	L__136
L__135:
	JP	PO,L_158
L__136:
;  589	
;  590			}
L_170:
.LINE 590

;  591			
;  592			if (bmp.bmp_bitdepth == 24) {
.LINE 592

	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%18
	JR	NZ,L_175
;  593			
;  594				//uint16_t new_row_size;
;  595				
;  596			    char * src = (char * ) malloc(bmp.bmp_width * bmp.bmp_bitdepth / 8);
.LINE 596

	LD	HL,-1117
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,8
	CALL	__idivs
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFE6),HL
;  597				mos_flseek(file, bmp.pixels_offset + ((bmp.bmp_height - 1) * (bmp.non_pad_row + bmp.row_padding)));
.LINE 597

	LD	HL,-1115
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	DEC	DE
	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,BC
	LD	BC,-1129	; spill
	CALL	__istix
	LD	BC,(IX+%FFFFFFD0)
	CALL	__stoiu
	LD	BC,-1129	; unspill
	PUSH	HL
	CALL	__ildix
	LD	BC,HL
	POP	HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,HL
	CALL	__itol
	LD	IY,-1112
	LD	DE,IX
	ADD	IY,DE
	LD	HL,(IY)
	LD	E,(IY+%3)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  598				clear_buffer(slot);
.LINE 598

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_clear_buffer
	POP	BC
;  599				
;  600				for (y = bmp.bmp_height - 1; y >= 0; y--) {
.LINE 600

	LD	HL,-1115
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	DEC	HL
	LD	(IX+%FFFFFFFA),L
	LD	(IX+%FFFFFFFB),H
	JR	L_167
L_165:
;  601	
;  602					mos_fread(file, src, bmp.non_pad_row);
.LINE 602

	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	PUSH	HL
	LD	BC,(IX+%FFFFFFE6)
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  603					generic8888_to_rgba2222(src, row_rgba2222,bmp.bmp_width,bmp.bmp_bitdepth / 8,2,1,0,-1);
.LINE 603

	LD	BC,16777215
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,8
	CALL	__idivs
	LD	C,L
	LD	B,%0
	PUSH	BC
	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	PUSH	HL
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	BC,(IX+%FFFFFFE6)
	PUSH	BC
	CALL	_generic8888_to_rgba2222
	LD	IY,24
	ADD	IY,SP
	LD	SP,IY
;  604					add_stream_to_buffer(slot,row_rgba2222,bmp.bmp_width);
.LINE 604

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_add_stream_to_buffer
	POP	BC
	POP	BC
	POP	BC
;  605					mos_flseek(file, fo -> fptr - ((bmp.non_pad_row * 2) + bmp.row_padding));
.LINE 605

	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	ADD	HL,HL
	LD	DE,HL
	LD	BC,(IX+%FFFFFFD0)
	CALL	__stoiu
	ADD	HL,DE
	LD	BC,HL
	CALL	__itol
	LD	IY,(IX+%FFFFFFF0)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	CALL	__lsub
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
	LD	HL,(IX+%FFFFFFFA)
	DEC	HL
	LD	(IX+%FFFFFFFA),L
	LD	(IX+%FFFFFFFB),H
;  606	
;  607				}		
L_167:
.LINE 607

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC.SIS	HL,BC
	JP	P,L__137
	JP	PE,L_165
	JR	L__138
L__137:
	JP	PO,L_165
L__138:
;  608				free(src);
.LINE 608

	LD	BC,(IX+%FFFFFFE6)
	PUSH	BC
	CALL	_free
	POP	BC
;  609			
;  610			}
;  611		}
L_175:
.LINE 611

;  612		
;  613		assign_buffer_to_bitmap(slot,1,bmp.bmp_width,bmp.bmp_height);
.LINE 613

	LD	HL,-1115
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_assign_buffer_to_bitmap
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  614		free(row_rgba2222);
.LINE 614

	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	CALL	_free
	POP	BC
;  615		
;  616		mos_fclose(file);
.LINE 616

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  617		return bmp;
.LINE 617

	LEA	HL,IX+%6
	LD	DE,(HL)
	LD	HL,IX
	LD	BC,-1117
	ADD	HL,BC
	LD	BC,1073
	LDIR	
	LD	HL,(IX+%6)
;  618		
;  619	}
L_176:
.LINE 619

	LD	SP,IX
	POP	IX
	RET	


;**************************** _load_bmp_clean ***************************
;Name                         Addr/Register   Size   Type
;_mos_fclose                         IMPORT  -----   function
;_mos_fgetc                          IMPORT  -----   function
;_free                               IMPORT  -----   function
;_mos_flseek                         IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;_mos_fread                          IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_mos_getfil                         IMPORT  -----   function
;_mos_fopen                          IMPORT  -----   function
;_memset                             IMPORT  -----   function
;bmp                                IX-1117   1073   variable
;initial_header                       IX-44     18   variable
;src                                  IX-26      3   variable
;r                                    IX-23      1   variable
;g                                    IX-22      1   variable
;b                                    IX-21      1   variable
;index                                IX-20      1   variable
;src                                  IX-19      3   variable
;fo                                   IX-16      3   variable
;y                                    IX-13      2   variable
;x                                    IX-11      2   variable
;row_rgba2222                          IX-9      3   variable
;y                                     IX-6      2   variable
;main_header                           IX-4      3   variable
;file                                  IX-1      1   variable
;slot                                 IX+12      1   parameter
;filename                              IX+9      3   parameter


; Stack Frame Size: 1150 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "load_bmp_clean",619,"_load_bmp_clean"
	SEGMENT STRSECT
L__110:
	DB	"Error: could not open "
	DB	0
L__111:
	DB	"."
	DB	13,10,0
L__117:
	DB	"Non standard BMP compression, exiting."
	DB	13,10,0
L__122:
	DB	"16-bit BMP files not supported, use 8-bit (small), 24-bit (fast) or 32-bit (alpha-enabled)."
	DB	13,10,0
L__127:
	DB	"16-bit BMP files not supported, use 8-bit (small), 24-bit (fast) or 32-bit (alpha-enabled)."
	DB	13,10,0
	SEGMENT CODE
;  620	
;  621	uint16_t strtou16(const char *str) {
_strtou16:
.DEFINE "_strtou16"

.VALUE _strtou16

.CLASS 2

.TYPE 77

.ENDEF

.BEGFUNC "strtou16",621,"_strtou16"

.LINE 621

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "result"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "digit"

.CLASS 65

.VALUE -4

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;  622	    uint16_t result = 0;
.LINE 622

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
;  623	    const uint16_t maxDiv10 = 6553;  // 65535 / 10
;  624	    const uint16_t maxMod10 = 5;     // 65535 % 10
;  625	
;  626	    while (*str == ' ' || *str == '\t' || *str == '\n') {
.LINE 626

	JR	L_180
L_181:
;  627	        str++;
.LINE 627

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  628	    }
L_180:
.LINE 628

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	Z,L_181
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	Z,L_181
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,10
	OR	A,A
	SBC	HL,BC
	JR	Z,L_181
;  629	
;  630	    while (*str >= '0' && *str <= '9') {
.LINE 630

	JR	L_188
L_189:
;  631	        uint16_t digit = *str - '0';
.LINE 631

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LEA	HL,IY+%FFFFFFD0
	LD	(IX+%FFFFFFFC),L
	LD	(IX+%FFFFFFFD),H
;  632	        if (result > maxDiv10 || (result == maxDiv10 && digit > maxMod10)) {
.LINE 632

	LD	BC,(IX+%FFFFFFFE)
	LD.LIS	HL,6553
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_185
	LD.LIS	BC,6553
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_186
	LD	BC,(IX+%FFFFFFFC)
	LD.LIS	HL,5
	OR	A,A
	SBC.SIS	HL,BC
	JR	NC,L_186
L_185:
;  633	            return 65535;
.LINE 633

	LD.LIS	HL,65535
	JR	L_192
;  634	        }
L_186:
.LINE 634

;  635	        result = result * 10 + digit;
.LINE 635

	LD.LIS	HL,10
	LD	BC,(IX+%FFFFFFFE)
	CALL	__smulu
	LD	BC,(IX+%FFFFFFFC)
	ADD.SIS	HL,BC
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;  636	        str++;
.LINE 636

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  637	    }
L_188:
.LINE 637

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,48
	OR	A,A
	SBC	HL,BC
	JP	M,L__148
	JP	PE,L_191
	JR	L__149
L__148:
	JP	PO,L_191
L__149:
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	JP	P,L__150
	JP	PE,L_189
	JR	L__151
L__150:
	JP	PO,L_189
L__151:
L_191:
;  638	
;  639	    return result;
.LINE 639

	LD	HL,(IX+%FFFFFFFE)
;  640	}
L_192:
.LINE 640

	LD	SP,IX
	POP	IX
	RET	


;**************************** _strtou16 ***************************
;Name                         Addr/Register   Size   Type
;digit                                 IX-4      2   variable
;result                                IX-2      2   variable
;str                                   IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "strtou16",640,"_strtou16"
;  641	
;  642	uint8_t strtou8(const char *str) {
_strtou8:
.DEFINE "_strtou8"

.VALUE _strtou8

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "strtou8",642,"_strtou8"

.LINE 642

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "result"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "digit"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;  643	    uint8_t result = 0;
.LINE 643

	LD	(IX+%FFFFFFFF),%0
;  644	    const uint8_t maxDiv10 = 255 / 10;
;  645	    const uint8_t maxMod10 = 255 % 10;
;  646	
;  647	    while (*str == ' ' || *str == '\t' || *str == '\n') {
.LINE 647

	JR	L_196
L_197:
;  648	        str++;
.LINE 648

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  649	    }
L_196:
.LINE 649

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	Z,L_197
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	Z,L_197
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,10
	OR	A,A
	SBC	HL,BC
	JR	Z,L_197
;  650	
;  651	    while (*str >= '0' && *str <= '9') {
.LINE 651

	JR	L_204
L_205:
;  652	        uint8_t digit = *str - '0';
.LINE 652

	LD	HL,(IX+%6)
	LD	A,(HL)
	SUB	A,%30
	LD	(IX+%FFFFFFFE),A
;  653	        if (result > maxDiv10 || (result == maxDiv10 && digit > maxMod10)) {
.LINE 653

	LD	A,%19
	CP	A,(IX+%FFFFFFFF)
	JR	C,L_201
	LD	A,(IX+%FFFFFFFF)
	CP	A,%19
	JR	NZ,L_202
	LD	A,%5
	CP	A,(IX+%FFFFFFFE)
	JR	NC,L_202
L_201:
;  654	            return 255;
.LINE 654

	LD	A,%FF
	JR	L_208
;  655	        }
L_202:
.LINE 655

;  656	        result = result * 10 + digit;
.LINE 656

	LD	B,%A
	LD	C,(IX+%FFFFFFFF)
	MLT	BC
	LD	A,C
	ADD	A,(IX+%FFFFFFFE)
	LD	(IX+%FFFFFFFF),A
;  657	        str++;
.LINE 657

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  658	    }
L_204:
.LINE 658

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,48
	OR	A,A
	SBC	HL,BC
	JP	M,L__161
	JP	PE,L_207
	JR	L__162
L__161:
	JP	PO,L_207
L__162:
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	JP	P,L__163
	JP	PE,L_205
	JR	L__164
L__163:
	JP	PO,L_205
L__164:
L_207:
;  659	
;  660	    return result;
.LINE 660

	LD	A,(IX+%FFFFFFFF)
;  661	}
L_208:
.LINE 661

	LD	SP,IX
	POP	IX
	RET	


;**************************** _strtou8 ***************************
;Name                         Addr/Register   Size   Type
;digit                                 IX-2      1   variable
;result                                IX-1      1   variable
;str                                   IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "strtou8",661,"_strtou8"
;  662	
;  663	uint24_t strtou24(const char *str) {
_strtou24:
.DEFINE "_strtou24"

.VALUE _strtou24

.CLASS 2

.TYPE 78

.ENDEF

.BEGFUNC "strtou24",663,"_strtou24"

.LINE 663

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "result"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

.DEFINE "digit"

.CLASS 65

.VALUE -8

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	DEC	SP
	DEC	SP
;  664	    uint32_t result = 0;
.LINE 664

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
;  665	    const uint32_t maxDiv10 = 1677721;
;  666	    const uint32_t maxMod10 = 5;
;  667	
;  668	    while (*str == ' ' || *str == '\t' || *str == '\n') {
.LINE 668

	JR	L_212
L_213:
;  669	        str++;
.LINE 669

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  670	    }
L_212:
.LINE 670

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	Z,L_213
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	Z,L_213
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,10
	OR	A,A
	SBC	HL,BC
	JR	Z,L_213
;  671		
;  672	    while (*str >= '0' && *str <= '9') {
.LINE 672

	JR	L_220
L_221:
;  673	        uint32_t digit = *str - '0';
.LINE 673

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	E,H
	LD	BC,48
	XOR	A,A
	CALL	__lsub
	LD	(IX+%FFFFFFF8),HL
	LD	(IX+%FFFFFFFB),E
;  674	        if (result > maxDiv10 || (result == maxDiv10 && digit > maxMod10)) {
.LINE 674

	LD	HL,1677721
	LD	E,%0
	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	CALL	__lcmpu
	JR	C,L_217
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,1677721
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_218
	LD	HL,5
	LD	E,%0
	LD	BC,(IX+%FFFFFFF8)
	LD	A,(IX+%FFFFFFFB)
	CALL	__lcmpu
	JR	NC,L_218
L_217:
;  675	            return 16777215;
.LINE 675

	LD	HL,16777215
	JR	L_224
;  676	        }
L_218:
.LINE 676

;  677	        result = result * 10 + digit;
.LINE 677

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,10
	XOR	A,A
	CALL	__lmulu
	LD	BC,(IX+%FFFFFFF8)
	LD	A,(IX+%FFFFFFFB)
	CALL	__ladd
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;  678	        str++;
.LINE 678

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  679	    }
L_220:
.LINE 679

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,48
	OR	A,A
	SBC	HL,BC
	JP	M,L__174
	JP	PE,L_223
	JR	L__175
L__174:
	JP	PO,L_223
L__175:
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	JP	P,L__176
	JP	PE,L_221
	JR	L__177
L__176:
	JP	PO,L_221
L__177:
L_223:
;  680	
;  681	    return result;
.LINE 681

	LD	HL,(IX+%FFFFFFFC)
;  682	}
L_224:
.LINE 682

	LD	SP,IX
	POP	IX
	RET	


;**************************** _strtou24 ***************************
;Name                         Addr/Register   Size   Type
;digit                                 IX-8      4   variable
;result                                IX-4      4   variable
;str                                   IX+6      3   parameter


; Stack Frame Size: 17 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "strtou24",682,"_strtou24"
;  683	
;  684	int main(int argc, char * argv[]) {
_main:
.DEFINE "_main"

.VALUE _main

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "main",684,"_main"

.LINE 684

.DEFINE "argc"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "argv"

.CLASS 65

.VALUE 9

.TYPE 290

.ENDEF

.DEFINE "bitmap_slot"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -7

.TYPE 14

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -13

.TYPE 14

.ENDEF

.DEFINE "bmp"

.CLASS 65

.VALUE -1086

.TAG "NONAME6"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-6452
	ADD	HL,SP
	LD	SP,HL
;  685	
;  686	    uint24_t x, y;
;  687		uint8_t bitmap_slot = 0;
.LINE 687

	LD	(IX+%FFFFFFFF),%0
;  688		bmp_info bmp;
;  689		
;  690		//Args = 0:binary name, 1:filname, 2:slot, 3:topleft, 3:topright
;  691		
;  692		if ((argc < 2) || (argc == 4) || (argc > 5)) {
.LINE 692

	LD	BC,2
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JP	M,L__192
	JP	PE,L_227
	JR	L__193
L__192:
	JP	PO,L_227
L__193:
	LD	BC,4
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_227
	LD	BC,(IX+%6)
	LD	HL,5
	OR	A,A
	SBC	HL,BC
	JP	P,L__194
	JP	PE,L_229
	JR	L__195
L__194:
	JP	PO,L_229
L__195:
L_227:
;  693	        // printf("Usage is %s <filename> [bitmap slot] [top-left x] [top-left y]\r\n", argv[0]);
;  694	        // return 0;
;  695			bmp = load_bmp_clean(argv[1], 0);
.LINE 695

	LD	BC,0
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	LD	HL,IX
	LD	BC,-2159
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_load_bmp_clean
	POP	BC
	POP	BC
	POP	BC
	LD	IY,IX
	LD	BC,-1086
	ADD	IY,BC
	LD	DE,IY
	LD	BC,1073
	LDIR	
;  696	    }
L_229:
.LINE 696

;  697		
;  698		if (argc > 2) bitmap_slot = strtou8(argv[2]);
.LINE 698

	LD	BC,(IX+%6)
	LD	HL,2
	OR	A,A
	SBC	HL,BC
	JP	P,L__196
	JP	PE,L_245
	JR	L__197
L__196:
	JP	PO,L_245
L__197:
	LD	IY,(IX+%9)
	LEA	HL,IY+%6
	LD	BC,(HL)
	PUSH	BC
	CALL	_strtou8
	POP	BC
	LD	(IX+%FFFFFFFF),A
L_245:
;  699		
;  700	    //vdp_mode(8);
;  701		
;  702		if (argc == 2) {
.LINE 702

	LD	BC,2
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_244
;  703			
;  704			bmp = load_bmp_clean(argv[1], 0);
.LINE 704

	LD	BC,0
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	LD	HL,IX
	LD	BC,-3232
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_load_bmp_clean
	POP	BC
	POP	BC
	POP	BC
	LD	IY,IX
	LD	BC,-1086
	ADD	IY,BC
	LD	DE,IY
	LD	BC,1073
	LDIR	
;  705			
;  706		} else if (argc == 3) {
.LINE 706

	JR	L_246
L_244:
	LD	BC,3
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_242
;  707			
;  708			if (strcmp(argv[2], "/i") == 0) get_info(argv[1]);
.LINE 708

	LD	BC,L__185
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%6
	LD	BC,(HL)
	PUSH	BC
	CALL	_strcmp
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_231
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	LD	HL,IX
	LD	BC,-4305
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_get_info
	POP	BC
	POP	BC
;  709			else bmp = load_bmp_clean(argv[1], bitmap_slot);
.LINE 709

	JR	L_246
L_231:
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	LD	HL,IX
	LD	BC,-5378
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_load_bmp_clean
	POP	BC
	POP	BC
	POP	BC
	LD	IY,IX
	LD	BC,-1086
	ADD	IY,BC
	LD	DE,IY
	LD	BC,1073
	LDIR	
;  710			
;  711		} else if (argc == 5) {
.LINE 711

	JR	L_246
L_242:
	LD	BC,5
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_246
;  712		
;  713			bmp = load_bmp_clean(argv[1], bitmap_slot);
.LINE 713

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	LD	HL,IX
	LD	BC,-6451
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_load_bmp_clean
	POP	BC
	POP	BC
	POP	BC
	LD	IY,IX
	LD	BC,-1086
	ADD	IY,BC
	LD	DE,IY
	LD	BC,1073
	LDIR	
;  714			
;  715			if (argv[3][0] == 'C' || argv[3][0] == 'c') x = (getsysvar_scrwidth() - bmp.bmp_width) / 2;
.LINE 715

	LD	IY,(IX+%9)
	LEA	IY,IY+%9
	LD	(IX+%FFFFFFF6),IY
	LD	HL,(IX+%FFFFFFF6)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,67
	OR	A,A
	SBC	HL,BC
	JR	Z,L_233
	LD	HL,(IX+%FFFFFFF6)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,99
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_234
L_233:
	PUSH	IY
	PUSH	BC
	LD	IY,-6452
	LD	BC,IX
	ADD	IY,BC
	LD	(IY),A
	POP	BC
	POP	IY
	CALL	_getsysvar_scrwidth
	PUSH	IY
	PUSH	BC
	LD	IY,-6452
	LD	BC,IX
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	POP	IY
	LD	BC,HL
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1086
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	LD	BC,2
	CALL	__idivs
	LD	(IX+%FFFFFFF9),HL
;  716			else x = strtou16(argv[4]);
.LINE 716

	JR	L_238
L_234:
	LD	IY,(IX+%9)
	LEA	HL,IY+%C
	LD	BC,(HL)
	PUSH	BC
	CALL	_strtou16
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	(IX+%FFFFFFF9),HL
L_238:
;  717			
;  718			if (argv[4][0] == 'C' || argv[4][0] == 'c') y = (getsysvar_scrheight() - bmp.bmp_height) / 2;
.LINE 718

	LD	IY,(IX+%9)
	LEA	IY,IY+%C
	LD	(IX+%FFFFFFFC),IY
	LD	HL,(IX+%FFFFFFFC)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,67
	OR	A,A
	SBC	HL,BC
	JR	Z,L_236
	LD	HL,(IX+%FFFFFFFC)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,99
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_237
L_236:
	PUSH	IY
	PUSH	BC
	LD	IY,-6452
	LD	BC,IX
	ADD	IY,BC
	LD	(IY),A
	POP	BC
	POP	IY
	CALL	_getsysvar_scrheight
	PUSH	IY
	PUSH	BC
	LD	IY,-6452
	LD	BC,IX
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	POP	IY
	LD	BC,HL
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1084
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	LD	BC,2
	CALL	__idivs
	LD	(IX+%FFFFFFF3),HL
;  719			else y = strtou16(argv[4]);
.LINE 719

	JR	L_239
L_237:
	LD	HL,(IX+%FFFFFFFC)
	LD	BC,(HL)
	PUSH	BC
	CALL	_strtou16
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	(IX+%FFFFFFF3),HL
L_239:
;  720			
;  721			vdp_extended_select(bitmap_slot);
.LINE 721

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_vdp_extended_select
	POP	BC
;  722			vdp_bitmapDrawSelected(x,y);
.LINE 722

	LD	BC,(IX+%FFFFFFF3)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	CALL	_vdp_bitmapDrawSelected
	POP	BC
	POP	BC
;  723			
;  724		}
L_246:
.LINE 724

;  725	
;  726	    return 0;
.LINE 726

	OR	A,A
	SBC	HL,HL
.LINE 727

	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_vdp_bitmapDrawSelected             IMPORT  -----   function
;_getsysvar_scrheight                IMPORT  -----   function
;_getsysvar_scrwidth                 IMPORT  -----   function
;_strcmp                             IMPORT  -----   function
;bmp                                IX-1086   1073   variable
;y                                    IX-13      3   variable
;G_1                                  IX-10      3   variable
;x                                     IX-7      3   variable
;G_2                                   IX-4      3   variable
;bitmap_slot                           IX-1      1   variable
;argv                                  IX+9      3   parameter
;argc                                  IX+6      3   parameter


; Stack Frame Size: 6464 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "main",727,"_main"
	SEGMENT STRSECT
L__185:
	DB	"/i"
	DB	0
	XREF _write16bit:ROM
	XREF _vdp_bitmapDrawSelected:ROM
	XREF _mos_getfil:ROM
	XREF _mos_flseek:ROM
	XREF _mos_fread:ROM
	XREF _mos_fgetc:ROM
	XREF _mos_fclose:ROM
	XREF _mos_fopen:ROM
	XREF _getsysvar_scrheight:ROM
	XREF _getsysvar_scrwidth:ROM
	XREF _mos_puts:ROM
	XREF _waitvblank:ROM
	XREF _putch:ROM
	XREF _strcmp:ROM
	XREF _memset:ROM
	XREF _memcpy:ROM
	XREF _malloc:ROM
	XREF _free:ROM
	XREF __u_uitoa:ROM
	XREF __u_itoa:ROM
	XREF ___print_sendstring:ROM
	XREF ___print_xputch:ROM
	XREF ___print_uputch:ROM
	XREF ___print_fmt:ROM
	XREF __lcmpu:ROM
	XREF __ladd:ROM
	XREF __lsub:ROM
	XREF __idivs:ROM
	XREF __imuls:ROM
	XREF __lmulu:ROM
	XREF __smulu:ROM
	XREF __bshl:ROM
	XREF __irems:ROM
	XREF __ishrs:ROM
	XREF __stoi:ROM
	XREF __stoiu:ROM
	XREF __itol:ROM
	XREF __ildix:ROM
	XREF __istix:ROM
	XREF __ladd_b:ROM
	XREF __ishru_b:ROM
	XREF __ishrs_b:ROM
	XDEF _main
	XDEF _strtou24
	XDEF _strtou8
	XDEF _strtou16
	XDEF _load_bmp_clean
	XDEF _get_info
	XDEF _print_bin
	XDEF _count_trailing_zeros
	XDEF _getByte
	XDEF _rgbx5551_to_rgba2222
	XDEF _generic8888_to_rgba2222
	XDEF _bgra8888_to_rgba2222
	XDEF _bgr888_to_rgba2222
	XDEF _reorder_and_insert
	XDEF _reorder
	XDEF _assign_buffer_to_bitmap
	XDEF _vdp_extended_select
	XDEF _add_stream_to_buffer
	XDEF _clear_buffer
	XDEF _rgba8888_to_rgba2222
	XDEF _twiddle_buffer
	XDEF _flip
	XDEF _max
	XDEF _min
	XDEF _delay_secs
	END
