; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optspeed -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\main.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME0",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME1"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME2"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME2",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",8
.DEFINE "baudRate"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "dataBits"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stopBits"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "parity"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flowcontrol"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "eir"
.VALUE 7
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",15
.DEFINE "fs"
.VALUE 0
.CLASS 8
.TYPE 46
.ENDEF
.DEFINE "id"
.VALUE 3
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "attr"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stat"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "sclust"
.VALUE 7
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "objsize"
.VALUE 11
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",36
.DEFINE "obj"
.VALUE 0
.CLASS 8
.TAG "NONAME4"
.TYPE 8
.ENDEF
.DEFINE "flag"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "err"
.VALUE 16
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fptr"
.VALUE 17
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "clust"
.VALUE 21
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "sect"
.VALUE 25
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir_sect"
.VALUE 29
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir_ptr"
.VALUE 33
.CLASS 8
.TYPE 46
.ENDEF
.ENDREC "NONAME5"
;    1	//Copyright HeathenUK 2023, others' copyrights (Envenomator, Dean Belfield, etc.) unaffected.
;    2	
;    3	#include <stdio.h>
;    4	#include <stdlib.h>
;    5	#include <ctype.h>
;    6	#include <stdint.h>
;    7	#include <string.h>
;    8	#include <eZ80.h>
;    9	#include <defines.h>
;   10	#include "mos-interface.h"
;   11	#include "vdp.h"
;   12	
;   13	typedef struct {
;   14		
;   15		uint16_t bmp_width;
;   16		uint16_t bmp_height;
;   17		uint8_t  bmp_bitdepth;
;   18		
;   19		uint32_t pixels_offset;
;   20		uint32_t bmp_size;
;   21		uint32_t main_header_size;
;   22		
;   23		uint32_t compression;
;   24		
;   25		uint32_t redBitField;
;   26		uint32_t greenBitField;
;   27		uint32_t blueBitField;
;   28		uint32_t alphaBitField;
;   29		
;   30		uint32_t color_table_size;
;   31		char color_table[1024];
;   32		
;   33		int8_t red_pos;
;   34		int8_t green_pos;
;   35		int8_t blue_pos;
;   36		int8_t alpha_pos;
;   37		
;   38		uint16_t row_padding;
;   39		uint16_t non_pad_row;
;   40		
;   41	} bmp_info;
.BEGREC "NONAME6",1073
.DEFINE "bmp_width"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "bmp_height"
.VALUE 2
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "bmp_bitdepth"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pixels_offset"
.VALUE 5
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "bmp_size"
.VALUE 9
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "main_header_size"
.VALUE 13
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "compression"
.VALUE 17
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "redBitField"
.VALUE 21
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "greenBitField"
.VALUE 25
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "blueBitField"
.VALUE 29
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "alphaBitField"
.VALUE 33
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "color_table_size"
.VALUE 37
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "color_table"
.VALUE 41
.CLASS 8
.DIM 1024
.TYPE 98
.ENDEF
.DEFINE "red_pos"
.VALUE 1065
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "green_pos"
.VALUE 1066
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "blue_pos"
.VALUE 1067
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "alpha_pos"
.VALUE 1068
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "row_padding"
.VALUE 1069
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "non_pad_row"
.VALUE 1071
.CLASS 8
.TYPE 13
.ENDEF
.ENDREC "NONAME6"
;   42	
;   43	extern void write16bit(uint16_t w);
;   44	extern void write24bit(uint24_t w);
;   45	extern void write32bit(uint32_t w);
;   46	
;   47	void delay_secs(UINT16 ticks_end) { //1 sec ticks
_delay_secs:
.DEFINE "_delay_secs"

.VALUE _delay_secs

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "delay_secs",47,"_delay_secs"

.LINE 47

.DEFINE "ticks_end"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

.DEFINE "ticks"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;   48		
;   49		UINT32 ticks = 0;
.LINE 49

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
;   50		ticks_end *= 60;
.LINE 50

	LD.LIS	HL,60
	LD	BC,(IX+%6)
	CALL	__smulu
	LD	(IX+%6),L
	LD	(IX+%7),H
;   51		while(true) {
L_3:
.LINE 51

;   52			
;   53			waitvblank();
.LINE 53

	CALL	_waitvblank
;   54			ticks++;
.LINE 54

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;   55			if(ticks >= ticks_end) break;
.LINE 55

	LD	BC,(IX+%6)
	CALL	__stoiu
	LD	BC,HL
	XOR	A,A
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	CALL	__lcmpu
	JR	C,L_3
;   56			
;   57		}
;   58		
;   59	}
.LINE 59

	LD	SP,IX
	POP	IX
	RET	


;**************************** _delay_secs ***************************
;Name                         Addr/Register   Size   Type
;_waitvblank                         IMPORT  -----   function
;ticks                                 IX-4      4   variable
;ticks_end                             IX+6      2   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "delay_secs",59,"_delay_secs"
;   60	
;   61	int min(int a, int b) {
_min:
.DEFINE "_min"

.VALUE _min

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "min",61,"_min"

.LINE 61

.DEFINE "a"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   62	    if (a > b)
.LINE 62

	LD	BC,(IX+%6)
	LD	HL,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JP	P,L__3
	JP	PE,L_6
	JR	L__4
L__3:
	JP	PO,L_6
L__4:
;   63	        return b;
.LINE 63

	LD	HL,(IX+%9)
	JR	L_7
L_6:
;   64	    return a;
.LINE 64

	LD	HL,(IX+%6)
;   65	}
L_7:
.LINE 65

	LD	SP,IX
	POP	IX
	RET	


;**************************** _min ***************************
;Name                         Addr/Register   Size   Type
;b                                     IX+9      3   parameter
;a                                     IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "min",65,"_min"
;   66	
;   67	int max(int a, int b) {
_max:
.DEFINE "_max"

.VALUE _max

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "max",67,"_max"

.LINE 67

.DEFINE "a"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   68	    if (a > b)
.LINE 68

	LD	BC,(IX+%6)
	LD	HL,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JP	P,L__7
	JP	PE,L_9
	JR	L__8
L__7:
	JP	PO,L_9
L__8:
;   69	        return a;
.LINE 69

	LD	HL,(IX+%6)
	JR	L_10
L_9:
;   70	    return b;
.LINE 70

	LD	HL,(IX+%9)
;   71	}
L_10:
.LINE 71

	LD	SP,IX
	POP	IX
	RET	


;**************************** _max ***************************
;Name                         Addr/Register   Size   Type
;b                                     IX+9      3   parameter
;a                                     IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "max",71,"_max"
;   72	
;   73	void flip(uint32_t * framebuffer, int width, int height) {
_flip:
.DEFINE "_flip"

.VALUE _flip

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "flip",73,"_flip"

.LINE 73

.DEFINE "framebuffer"

.CLASS 65

.VALUE 6

.TYPE 47

.ENDEF

.DEFINE "width"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE 12

.TYPE 4

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "row_buffer"

.CLASS 65

.VALUE -5

.TYPE 47

.ENDEF

.DEFINE "row_size"

.CLASS 65

.VALUE -8

.TYPE 4

.ENDEF

.DEFINE "top_row"

.CLASS 65

.VALUE -11

.TYPE 47

.ENDEF

.DEFINE "bottom_row"

.CLASS 65

.VALUE -14

.TYPE 47

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF1
	LD	SP,HL
;   74	    uint16_t y;
;   75	    uint32_t * row_buffer = (uint32_t * ) malloc(sizeof(uint32_t) * width);
.LINE 75

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	LD	(IX+%FFFFFFF1),A
	CALL	_malloc
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	LD	(IX+%FFFFFFFB),HL
;   76	    int row_size = width * sizeof(uint32_t);
.LINE 76

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	(IX+%FFFFFFF8),HL
;   77	
;   78	    for (y = 0; y < height / 2; y++) {
.LINE 78

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_14
L_12:
;   79	        uint32_t * top_row = framebuffer + y * width;
.LINE 79

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF5),HL
;   80	        uint32_t * bottom_row = framebuffer + (height - y - 1) * width;
.LINE 80

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	DEC	HL
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF2),HL
;   81	
;   82	        memcpy(row_buffer, top_row, row_size);
.LINE 82

	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	LD	(IX+%FFFFFFF1),A
	CALL	_memcpy
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	POP	BC
	POP	BC
;   83	        memcpy(top_row, bottom_row, row_size);
.LINE 83

	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF2)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	(IX+%FFFFFFF1),A
	CALL	_memcpy
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	POP	BC
	POP	BC
;   84	        memcpy(bottom_row, row_buffer, row_size);
.LINE 84

	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF2)
	PUSH	BC
	LD	(IX+%FFFFFFF1),A
	CALL	_memcpy
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	POP	BC
	POP	BC
	LD	HL,(IX+%FFFFFFFE)
	INC	HL
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;   85	    }
L_14:
.LINE 85

	LD	BC,2
	LD	HL,(IX+%C)
	CALL	__idivs
	LD	DE,HL
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	OR	A,A
	SBC	HL,DE
	JP	M,L__11
	JP	PE,L_12
	JR	L__12
L__11:
	JP	PO,L_12
L__12:
;   86	
;   87	    free(row_buffer);
.LINE 87

	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	CALL	_free
	POP	BC
;   88	}
.LINE 88

	LD	SP,IX
	POP	IX
	RET	


;**************************** _flip ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_memcpy                             IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;bottom_row                           IX-14      3   variable
;top_row                              IX-11      3   variable
;row_size                              IX-8      3   variable
;row_buffer                            IX-5      3   variable
;y                                     IX-2      2   variable
;height                               IX+12      3   parameter
;width                                 IX+9      3   parameter
;framebuffer                           IX+6      3   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "flip",88,"_flip"
;   89	
;   90	void twiddle_buffer(char* buffer, int width, int height) {
_twiddle_buffer:
.DEFINE "_twiddle_buffer"

.VALUE _twiddle_buffer

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "twiddle_buffer",90,"_twiddle_buffer"

.LINE 90

.DEFINE "buffer"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "width"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE 12

.TYPE 4

.ENDEF

.DEFINE "col"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "tempRow"

.CLASS 65

.VALUE -6

.TYPE 34

.ENDEF

.DEFINE "oppositeRowPtr"

.CLASS 65

.VALUE -9

.TYPE 34

.ENDEF

.DEFINE "rowPtr"

.CLASS 65

.VALUE -12

.TYPE 34

.ENDEF

.DEFINE "row"

.CLASS 65

.VALUE -15

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE4
	LD	SP,HL
;   91	    int row, col;
;   92	    char* rowPtr;
;   93		char* oppositeRowPtr;
;   94		char* tempRow = (char*)malloc(width * 4);
.LINE 94

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	LD	(IX+%FFFFFFE4),A
	CALL	_malloc
	LD	A,(IX+%FFFFFFE4)
	POP	BC
	LD	(IX+%FFFFFFFA),HL
;   95	
;   96	    //Iterate over each row
;   97	    for (row = 0; row < height / 2; row++) {
.LINE 97

	LD	BC,0
	LD	(IX+%FFFFFFF1),BC
	JR	L_24
L_22:
;   98	        rowPtr = buffer + row * width * 4;
.LINE 98

	LD	HL,(IX+%FFFFFFF1)
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF4),HL
;   99	        oppositeRowPtr = buffer + (height - row - 1) * width * 4;
.LINE 99

	LD	BC,(IX+%FFFFFFF1)
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	DEC	HL
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF7),HL
;  100	
;  101	        //Swap bytes within each row (BGRA to RGBA)
;  102	        for (col = 0; col < width; col++) {
.LINE 102

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_21
L_19:
;  103	            tempRow[col * 4] = oppositeRowPtr[col * 4 + 2]; // R
.LINE 103

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,(IX+%FFFFFFF7)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	LD	A,(IY+%2)
	LD	(HL),A
;  104	            tempRow[col * 4 + 1] = oppositeRowPtr[col * 4 + 1]; // G
.LINE 104

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,DE
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	INC	HL
	LD	A,(IY+%1)
	LD	(HL),A
;  105	            tempRow[col * 4 + 2] = oppositeRowPtr[col * 4]; // B
.LINE 105

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	INC	HL
	INC	HL
	LD	A,(IY)
	LD	(HL),A
;  106	            tempRow[col * 4 + 3] = oppositeRowPtr[col * 4 + 3]; // A
.LINE 106

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	IY,HL
	LD	(IX+%FFFFFFEE),HL	; spill
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFEB),HL	; spill
	LD	BC,DE
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%FFFFFFEB)	; unspill
	LD	A,(HL)
	LD	(IY+%3),A
;  107	
;  108	            oppositeRowPtr[col * 4] = rowPtr[col * 4 + 2]; // R
.LINE 108

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,DE
	LD	A,(IY+%2)
	LD	(HL),A
;  109	            oppositeRowPtr[col * 4 + 1] = rowPtr[col * 4 + 1]; // G
.LINE 109

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,DE
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	INC	HL
	LD	A,(IY+%1)
	LD	(HL),A
;  110	            oppositeRowPtr[col * 4 + 2] = rowPtr[col * 4]; // B
.LINE 110

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,DE
	INC	HL
	INC	HL
	LD	A,(IY)
	LD	(HL),A
;  111	            oppositeRowPtr[col * 4 + 3] = rowPtr[col * 4 + 3]; // A
.LINE 111

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,BC
	LD	IY,HL
	LD	(IX+%FFFFFFEE),HL	; spill
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFE8),HL	; spill
	LD	BC,DE
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%FFFFFFE8)	; unspill
	LD	A,(HL)
	LD	(IY+%3),A
;  112	
;  113	            rowPtr[col * 4] = tempRow[col * 4]; // R
.LINE 113

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	LD	A,(IY)
	LD	(HL),A
;  114	            rowPtr[col * 4 + 1] = tempRow[col * 4 + 1]; // G
.LINE 114

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,DE
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,BC
	INC	HL
	LD	A,(IY+%1)
	LD	(HL),A
;  115	            rowPtr[col * 4 + 2] = tempRow[col * 4 + 2]; // B
.LINE 115

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	INC	HL
	INC	HL
	LD	A,(IY+%2)
	LD	(HL),A
;  116	            rowPtr[col * 4 + 3] = tempRow[col * 4 + 3]; // A
.LINE 116

	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	IY,HL
	LD	(IX+%FFFFFFEE),HL	; spill
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFE5),HL	; spill
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF4)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%FFFFFFE5)	; unspill
	LD	A,(HL)
	LD	(IY+%3),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  117	        }
L_21:
.LINE 117

	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JP	M,L__16
	JP	PE,L_19
	JR	L__17
L__16:
	JP	PO,L_19
L__17:
	LD	BC,(IX+%FFFFFFF1)
	INC	BC
	LD	(IX+%FFFFFFF1),BC
;  118	    }
L_24:
.LINE 118

	LD	BC,2
	LD	HL,(IX+%C)
	CALL	__idivs
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF1)
	OR	A,A
	SBC	HL,BC
	JP	M,L__18
	JP	PE,L_22
	JR	L__19
L__18:
	JP	PO,L_22
L__19:
;  119		free(tempRow);
.LINE 119

	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_free
	POP	BC
;  120	}
.LINE 120

	LD	SP,IX
	POP	IX
	RET	


;**************************** _twiddle_buffer ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;row                                  IX-15      3   variable
;rowPtr                               IX-12      3   variable
;oppositeRowPtr                        IX-9      3   variable
;tempRow                               IX-6      3   variable
;col                                   IX-3      3   variable
;height                               IX+12      3   parameter
;width                                 IX+9      3   parameter
;buffer                                IX+6      3   parameter


; Stack Frame Size: 43 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "twiddle_buffer",120,"_twiddle_buffer"
;  121	
;  122	// void bgra8888_to_rgba2222(char *input, char *output, uint16_t num_pixels) {
;  123	    // 
;  124		// char *input_ptr = input;
;  125	    // char *output_ptr = output;
;  126	
;  127	    // while (num_pixels--) {
;  128	
;  129	        // *output_ptr = CONVR64[input[2] >> 6] + CONVG64[input[1] >> 6] + CONVB64[input[0] >> 6] + CONVA64[input[3] >> 6];
;  130	
;  131	        // input_ptr += 4;
;  132	        // output_ptr++;
;  133			// 
;  134	    // }
;  135	// }
;  136	
;  137	void rgba8888_to_rgba2222(char *input, char *output, size_t num_pixels) {
_rgba8888_to_rgba2222:
.DEFINE "_rgba8888_to_rgba2222"

.VALUE _rgba8888_to_rgba2222

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "rgba8888_to_rgba2222",137,"_rgba8888_to_rgba2222"

.LINE 137

.DEFINE "input"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "output"

.CLASS 65

.VALUE 9

.TYPE 34

.ENDEF

.DEFINE "num_pixels"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "input_ptr"

.CLASS 65

.VALUE -3

.TYPE 34

.ENDEF

.DEFINE "output_ptr"

.CLASS 65

.VALUE -6

.TYPE 34

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "g"

.CLASS 65

.VALUE -8

.TYPE 12

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -9

.TYPE 12

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE -10

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE7
	LD	SP,HL
;  138	    char *input_ptr = input;
.LINE 138

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
;  139	    char *output_ptr = output;
.LINE 139

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFFA),BC
;  140	
;  141	    while (num_pixels--) {
.LINE 141

	JR	L_33
L_34:
;  142	        uint8_t r = *input_ptr++;
.LINE 142

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF3),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFF3)
	LD	A,(HL)
	LD	(IX+%FFFFFFF9),A
;  143			uint8_t g = *input_ptr++;
.LINE 143

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF0),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFF0)
	LD	A,(HL)
	LD	(IX+%FFFFFFF8),A
;  144			uint8_t b = *input_ptr++;
.LINE 144

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFED),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFED)
	LD	A,(HL)
	LD	(IX+%FFFFFFF7),A
;  145	        uint8_t a = *input_ptr++;
.LINE 145

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFEA),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFEA)
	LD	A,(HL)
	LD	(IX+%FFFFFFF6),A
;  146	
;  147	        *output_ptr++ = (r & 0xC0) | ((g & 0xC0) >> 2) | ((b & 0xC0) >> 4) | (a >> 6);
.LINE 147

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFE7),BC
	LD	A,(IX+%FFFFFFF8)
	SRL	A
	SRL	A
	AND	A,%30
	LD	L,A
	LD	A,(IX+%FFFFFFF9)
	AND	A,%C0
	LD	B,A
	LD	A,L
	OR	A,B
	LD	B,A
	LD	A,(IX+%FFFFFFF7)
	SRL	A
	SRL	A
	SRL	A
	SRL	A
	AND	A,%C
	LD	L,A
	LD	A,B
	OR	A,L
	LD	B,A
	LD	A,(IX+%FFFFFFF6)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,B
	OR	A,L
	LD	HL,(IX+%FFFFFFE7)
	LD	(HL),A
	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
;  148	    }
L_33:
.LINE 148

	LD	HL,(IX+%C)
	LD	IY,(IX+%C)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%C),IY
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_34
;  149	}
.LINE 149

	LD	SP,IX
	POP	IX
	RET	


;**************************** _rgba8888_to_rgba2222 ***************************
;Name                         Addr/Register   Size   Type
;a                                    IX-10      1   variable
;b                                     IX-9      1   variable
;g                                     IX-8      1   variable
;r                                     IX-7      1   variable
;output_ptr                            IX-6      3   variable
;input_ptr                             IX-3      3   variable
;num_pixels                           IX+12      3   parameter
;output                                IX+9      3   parameter
;input                                 IX+6      3   parameter


; Stack Frame Size: 40 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "rgba8888_to_rgba2222",149,"_rgba8888_to_rgba2222"
;  150	
;  151	void clear_buffer(uint16_t buffer_id) {
_clear_buffer:
.DEFINE "_clear_buffer"

.VALUE _clear_buffer

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "clear_buffer",151,"_clear_buffer"

.LINE 151

.DEFINE "buffer_id"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  152		
;  153		putch(23);
.LINE 153

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;  154		putch(0);
.LINE 154

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;  155		putch(0xA0);
.LINE 155

	LD	BC,160
	PUSH	BC
	CALL	_putch
	POP	BC
;  156		write16bit(buffer_id);
.LINE 156

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  157		putch(2);	
.LINE 157

	LD	BC,2
	PUSH	BC
	CALL	_putch
	POP	BC
;  158		
;  159	}
.LINE 159

	LD	SP,IX
	POP	IX
	RET	


;**************************** _clear_buffer ***************************
;Name                         Addr/Register   Size   Type
;_write16bit                         IMPORT  -----   function
;_putch                              IMPORT  -----   function
;buffer_id                             IX+6      2   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "clear_buffer",159,"_clear_buffer"
;  160	
;  161	void select_buffer (uint24_t buffer_id) {
_select_buffer:
.DEFINE "_select_buffer"

.VALUE _select_buffer

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "select_buffer",161,"_select_buffer"

.LINE 161

.DEFINE "buffer_id"

.CLASS 65

.VALUE 6

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  162		
;  163		putch(23);
.LINE 163

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;  164		putch(27);
.LINE 164

	LD	BC,27
	PUSH	BC
	CALL	_putch
	POP	BC
;  165		putch(0x20);
.LINE 165

	LD	BC,32
	PUSH	BC
	CALL	_putch
	POP	BC
;  166		write16bit(buffer_id);
.LINE 166

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  167		
;  168	}
.LINE 168

	LD	SP,IX
	POP	IX
	RET	


;**************************** _select_buffer ***************************
;Name                         Addr/Register   Size   Type
;_write16bit                         IMPORT  -----   function
;_putch                              IMPORT  -----   function
;buffer_id                             IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "select_buffer",168,"_select_buffer"
;  169	
;  170	void add_stream_to_buffer(uint16_t buffer_id, char* buffer_content, uint16_t buffer_size) {	
_add_stream_to_buffer:
.DEFINE "_add_stream_to_buffer"

.VALUE _add_stream_to_buffer

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "add_stream_to_buffer",170,"_add_stream_to_buffer"

.LINE 170

.DEFINE "buffer_id"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

.DEFINE "buffer_content"

.CLASS 65

.VALUE 9

.TYPE 34

.ENDEF

.DEFINE "buffer_size"

.CLASS 65

.VALUE 12

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  171	
;  172		putch(23);
.LINE 172

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;  173		putch(0);
.LINE 173

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;  174		putch(0xA0);
.LINE 174

	LD	BC,160
	PUSH	BC
	CALL	_putch
	POP	BC
;  175		write16bit(buffer_id);
.LINE 175

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  176		putch(0);
.LINE 176

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;  177		write16bit(buffer_size);
.LINE 177

	LD	BC,(IX+%C)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  178		
;  179		mos_puts(buffer_content, buffer_size, 0);
.LINE 179

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%C)
	CALL	__stoiu
	PUSH	HL
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	_mos_puts
	POP	BC
	POP	BC
	POP	BC
;  180	
;  181	}
.LINE 181

	LD	SP,IX
	POP	IX
	RET	


;**************************** _add_stream_to_buffer ***************************
;Name                         Addr/Register   Size   Type
;_mos_puts                           IMPORT  -----   function
;_write16bit                         IMPORT  -----   function
;_putch                              IMPORT  -----   function
;buffer_size                          IX+12      2   parameter
;buffer_content                        IX+9      3   parameter
;buffer_id                             IX+6      2   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "add_stream_to_buffer",181,"_add_stream_to_buffer"
;  182	
;  183	void vdp_extended_select(uint16_t buffer_id) {	
_vdp_extended_select:
.DEFINE "_vdp_extended_select"

.VALUE _vdp_extended_select

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vdp_extended_select",183,"_vdp_extended_select"

.LINE 183

.DEFINE "buffer_id"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  184	
;  185		putch(23);
.LINE 185

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;  186		putch(27);
.LINE 186

	LD	BC,27
	PUSH	BC
	CALL	_putch
	POP	BC
;  187		putch(0x20);
.LINE 187

	LD	BC,32
	PUSH	BC
	CALL	_putch
	POP	BC
;  188		write16bit(buffer_id);
.LINE 188

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  189	
;  190	}
.LINE 190

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vdp_extended_select ***************************
;Name                         Addr/Register   Size   Type
;_write16bit                         IMPORT  -----   function
;_putch                              IMPORT  -----   function
;buffer_id                             IX+6      2   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "vdp_extended_select",190,"_vdp_extended_select"
;  191	
;  192	void assign_buffer_to_bitmap(uint16_t buffer_id, uint8_t bitmap_format, uint16_t width, uint16_t height) {
_assign_buffer_to_bitmap:
.DEFINE "_assign_buffer_to_bitmap"

.VALUE _assign_buffer_to_bitmap

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "assign_buffer_to_bitmap",192,"_assign_buffer_to_bitmap"

.LINE 192

.DEFINE "buffer_id"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

.DEFINE "bitmap_format"

.CLASS 65

.VALUE 9

.TYPE 12

.ENDEF

.DEFINE "width"

.CLASS 65

.VALUE 12

.TYPE 13

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE 15

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  193	
;  194		vdp_extended_select(buffer_id);
.LINE 194

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_vdp_extended_select
	POP	BC
;  195		
;  196		//Consolidate buffer: (if needed) VDU 23, 0, &A0, bufferId; &0C
;  197		
;  198		putch(23);
.LINE 198

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;  199		putch(0);
.LINE 199

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;  200		putch(0xA0);
.LINE 200

	LD	BC,160
	PUSH	BC
	CALL	_putch
	POP	BC
;  201		write16bit(buffer_id);
.LINE 201

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  202		putch(0x0E);
.LINE 202

	LD	BC,14
	PUSH	BC
	CALL	_putch
	POP	BC
;  203		
;  204		//Create bitmap from buffer: VDU 23, 27, &21, bufferId; format, width; height;
;  205		
;  206		putch(23);
.LINE 206

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;  207		putch(27);
.LINE 207

	LD	BC,27
	PUSH	BC
	CALL	_putch
	POP	BC
;  208		putch(0x21);
.LINE 208

	LD	BC,33
	PUSH	BC
	CALL	_putch
	POP	BC
;  209		//write16bit(buffer_id);
;  210		write16bit(width);
.LINE 210

	LD	BC,(IX+%C)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  211		write16bit(height);
.LINE 211

	LD	BC,(IX+%F)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  212		putch(bitmap_format);
.LINE 212

	LD	A,(IX+%9)
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;  213		
;  214	}
.LINE 214

	LD	SP,IX
	POP	IX
	RET	


;**************************** _assign_buffer_to_bitmap ***************************
;Name                         Addr/Register   Size   Type
;_write16bit                         IMPORT  -----   function
;_putch                              IMPORT  -----   function
;height                               IX+15      2   parameter
;width                                IX+12      2   parameter
;bitmap_format                         IX+9      1   parameter
;buffer_id                             IX+6      2   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "assign_buffer_to_bitmap",214,"_assign_buffer_to_bitmap"
;  215	
;  216	void reorder(char *arr, uint16_t length) {
_reorder:
.DEFINE "_reorder"

.VALUE _reorder

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "reorder",216,"_reorder"

.LINE 216

.DEFINE "arr"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "length"

.CLASS 65

.VALUE 9

.TYPE 13

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "temp"

.CLASS 65

.VALUE -3

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
;  217	    uint16_t i;
;  218		for (i = 0; i < length; i += 4) {
.LINE 218

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_44
L_42:
;  219	        if (i + 2 < length) {
.LINE 219

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	DE,HL
	INC	DE
	INC	DE
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JP	P,L__30
	JP	PE,L_43
	JR	L__31
L__30:
	JP	PO,L_43
L__31:
;  220	            uint8_t temp = arr[i];
.LINE 220

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFFA),HL
	LD	A,(HL)
	LD	(IX+%FFFFFFFD),A
;  221	            arr[i] = arr[i + 2];
.LINE 221

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	A,(IY+%2)
	LD	(HL),A
;  222	            arr[i + 2] = temp;
.LINE 222

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	INC	HL
	INC	HL
	LD	A,(IX+%FFFFFFFD)
	LD	(HL),A
;  223	        }
;  224	    }
L_43:
.LINE 224

	LD	IY,(IX+%FFFFFFFE)
	LEA	HL,IY+%4
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
L_44:
	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_42
;  225	}
.LINE 225

	LD	SP,IX
	POP	IX
	RET	


;**************************** _reorder ***************************
;Name                         Addr/Register   Size   Type
;temp                                  IX-3      1   variable
;i                                     IX-2      2   variable
;length                                IX+9      2   parameter
;arr                                   IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "reorder",225,"_reorder"
;  226	
;  227	void reorder_and_insert(char *arr, uint16_t length, char **new_arr, uint16_t *new_length, char insert_value) {
_reorder_and_insert:
.DEFINE "_reorder_and_insert"

.VALUE _reorder_and_insert

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "reorder_and_insert",227,"_reorder_and_insert"

.LINE 227

.DEFINE "arr"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "length"

.CLASS 65

.VALUE 9

.TYPE 13

.ENDEF

.DEFINE "new_arr"

.CLASS 65

.VALUE 12

.TYPE 290

.ENDEF

.DEFINE "new_length"

.CLASS 65

.VALUE 15

.TYPE 45

.ENDEF

.DEFINE "insert_value"

.CLASS 65

.VALUE 18

.TYPE 2

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "j"

.CLASS 65

.VALUE -4

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFED
	LD	SP,HL
;  228	
;  229		uint16_t i, j = 0;
.LINE 229

	LD	(IX+%FFFFFFFC),%0
	LD	(IX+%FFFFFFFD),%0
;  230	    *new_length = (length / 3) * 4 + (length % 3);
.LINE 230

	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,3
	CALL	__idivs
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,3
	CALL	__irems
	ADD	HL,DE
	LD	BC,HL
	LD	HL,(IX+%F)
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  231	    *new_arr = (char *) malloc(*new_length * sizeof(char));
.LINE 231

	LD	HL,(IX+%F)
	LD	BC,(HL)
	CALL	__stoiu
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	IY,(IX+%C)
	LD	(IY),HL
;  232	
;  233	    for (i = 0; i < length; i += 3) {
.LINE 233

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_56
L_54:
;  234	        
;  235	        (*new_arr)[j] = (i + 2 < length) ? arr[i + 2] : 0;
.LINE 235

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	DE,HL
	INC	DE
	INC	DE
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JP	P,L__36
	JP	PE,L_48
	JR	L__37
L__36:
	JP	PO,L_48
L__37:
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	(IX+%FFFFFFF9),HL
	JR	L_49
L_48:
	LD	BC,0
	LD	(IX+%FFFFFFF9),BC
L_49:
	LD	IY,(IX+%C)
	LD	BC,(IX+%FFFFFFFC)
	CALL	__stoiu
	LD	BC,(IY)
	ADD	HL,BC
	LD	(IX+%FFFFFFF3),HL
	LD	A,(IX+%FFFFFFF9)
	LD	HL,(IX+%FFFFFFF3)
	LD	(HL),A
;  236	        (*new_arr)[j + 1] = (i + 1 < length) ? arr[i + 1] : 0;
.LINE 236

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	DE,HL
	INC	DE
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JP	P,L__38
	JP	PE,L_52
	JR	L__39
L__38:
	JP	PO,L_52
L__39:
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	INC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	(IX+%FFFFFFF6),HL
	JR	L_53
L_52:
	LD	BC,0
	LD	(IX+%FFFFFFF6),BC
L_53:
	LD	A,(IX+%FFFFFFF6)
	LD	HL,(IX+%FFFFFFF3)
	INC	HL
	LD	(HL),A
;  237	        (*new_arr)[j + 2] = arr[i];
.LINE 237

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%C)
	LD	(IX+%FFFFFFED),HL	; spill
	LD	BC,(IX+%FFFFFFFC)
	CALL	__stoiu
	LD	(IX+%FFFFFFF0),HL	; spill
	LD	HL,(IX+%FFFFFFED)	; unspill
	LD	BC,(HL)
	LD	HL,(IX+%FFFFFFF0)	; unspill
	ADD	HL,BC
	INC	HL
	INC	HL
	LD	A,(IY)
	LD	(HL),A
;  238	        
;  239	        (*new_arr)[j + 3] = 0xFF;
.LINE 239

	LD	IY,(IX+%C)
	LD	BC,(IX+%FFFFFFFC)
	CALL	__stoiu
	LD	BC,(IY)
	ADD	HL,BC
	LD	IY,HL
	LEA	HL,IY+%3
	LD	(HL),%FF
;  240	
;  241	        j += 4;
.LINE 241

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%4
	LD	(IX+%FFFFFFFC),L
	LD	(IX+%FFFFFFFD),H
	LD	IY,(IX+%FFFFFFFE)
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;  242	    }
L_56:
.LINE 242

	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_54
;  243		
;  244	}
.LINE 244

	LD	SP,IX
	POP	IX
	RET	


;**************************** _reorder_and_insert ***************************
;Name                         Addr/Register   Size   Type
;_malloc                             IMPORT  -----   function
;G_0                                  IX-13      3   variable
;temp50                               IX-10      3   variable
;temp46                                IX-7      3   variable
;j                                     IX-4      2   variable
;i                                     IX-2      2   variable
;insert_value                         IX+18      1   parameter
;new_length                           IX+15      3   parameter
;new_arr                              IX+12      3   parameter
;length                                IX+9      2   parameter
;arr                                   IX+6      3   parameter


; Stack Frame Size: 40 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "reorder_and_insert",244,"_reorder_and_insert"
;  245	
;  246	void bgr888_to_rgba2222(char *input, char *output, size_t num_pixels) {
_bgr888_to_rgba2222:
.DEFINE "_bgr888_to_rgba2222"

.VALUE _bgr888_to_rgba2222

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "bgr888_to_rgba2222",246,"_bgr888_to_rgba2222"

.LINE 246

.DEFINE "input"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "output"

.CLASS 65

.VALUE 9

.TYPE 34

.ENDEF

.DEFINE "num_pixels"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "input_ptr"

.CLASS 65

.VALUE -3

.TYPE 34

.ENDEF

.DEFINE "output_ptr"

.CLASS 65

.VALUE -6

.TYPE 34

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "g"

.CLASS 65

.VALUE -8

.TYPE 12

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -9

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEE
	LD	SP,HL
;  247	    char *input_ptr = input;
.LINE 247

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
;  248	    char *output_ptr = output;
.LINE 248

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFFA),BC
;  249	
;  250	    while (num_pixels--) {
.LINE 250

	JR	L_63
L_64:
;  251	        uint8_t b = *input_ptr++;
.LINE 251

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF4),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFF4)
	LD	A,(HL)
	LD	(IX+%FFFFFFF9),A
;  252	        uint8_t g = *input_ptr++;
.LINE 252

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF1),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFF1)
	LD	A,(HL)
	LD	(IX+%FFFFFFF8),A
;  253	        uint8_t r = *input_ptr++;
.LINE 253

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFEE),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFEE)
	LD	A,(HL)
	LD	(IX+%FFFFFFF7),A
;  254	        uint8_t a = 0xFF; // Alpha channel is always set to max value
;  255	
;  256			// *output_ptr = 0;
;  257			// *output_ptr |= CONVR64[r >> 6];
;  258			// *output_ptr |= CONVG64[g >> 6];
;  259			// *output_ptr |= CONVB64[b >> 6];
;  260			// *output_ptr |= CONVA64[a >> 6];
;  261			// output_ptr++;
;  262			
;  263			*output_ptr = ((r >> 6) & 0x03) | 
;  264	              (((g >> 6) & 0x03) << 2) | 
;  265	              (((b >> 6) & 0x03) << 4) | 
;  266	              (((a >> 6) & 0x03) << 6);	
.LINE 266

	LD	A,(IX+%FFFFFFF8)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	LD	B,A
	LD	A,(IX+%FFFFFFF7)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	LD	C,A
	LD	A,B
	OR	A,C
	LD	B,A
	LD	A,(IX+%FFFFFFF9)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	A,B
	OR	A,C
	OR	A,%C0
	LD	HL,(IX+%FFFFFFFA)
	LD	(HL),A
;  267			output_ptr++;
.LINE 267

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
;  268			
;  269	    }
L_63:
.LINE 269

	LD	HL,(IX+%C)
	LD	IY,(IX+%C)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%C),IY
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_64
;  270	}
.LINE 270

	LD	SP,IX
	POP	IX
	RET	


;**************************** _bgr888_to_rgba2222 ***************************
;Name                         Addr/Register   Size   Type
;r                                     IX-9      1   variable
;g                                     IX-8      1   variable
;b                                     IX-7      1   variable
;output_ptr                            IX-6      3   variable
;input_ptr                             IX-3      3   variable
;num_pixels                           IX+12      3   parameter
;output                                IX+9      3   parameter
;input                                 IX+6      3   parameter


; Stack Frame Size: 33 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "bgr888_to_rgba2222",270,"_bgr888_to_rgba2222"
;  271	
;  272	void bgra8888_to_rgba2222(char *input, char *output, size_t num_pixels) {
_bgra8888_to_rgba2222:
.DEFINE "_bgra8888_to_rgba2222"

.VALUE _bgra8888_to_rgba2222

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "bgra8888_to_rgba2222",272,"_bgra8888_to_rgba2222"

.LINE 272

.DEFINE "input"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "output"

.CLASS 65

.VALUE 9

.TYPE 34

.ENDEF

.DEFINE "num_pixels"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "input_ptr"

.CLASS 65

.VALUE -3

.TYPE 34

.ENDEF

.DEFINE "output_ptr"

.CLASS 65

.VALUE -6

.TYPE 34

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "g"

.CLASS 65

.VALUE -8

.TYPE 12

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -9

.TYPE 12

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE -10

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEA
	LD	SP,HL
;  273	    char *input_ptr = input;
.LINE 273

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
;  274	    char *output_ptr = output;
.LINE 274

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFFA),BC
;  275	
;  276	    while (num_pixels--) {
.LINE 276

	JR	L_72
L_73:
;  277	        uint8_t b = *input_ptr++;
.LINE 277

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF3),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFF3)
	LD	A,(HL)
	LD	(IX+%FFFFFFF9),A
;  278	        uint8_t g = *input_ptr++;
.LINE 278

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF0),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFF0)
	LD	A,(HL)
	LD	(IX+%FFFFFFF8),A
;  279	        uint8_t r = *input_ptr++;
.LINE 279

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFED),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFED)
	LD	A,(HL)
	LD	(IX+%FFFFFFF7),A
;  280	        uint8_t a = *input_ptr++;;
.LINE 280

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFEA),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFEA)
	LD	A,(HL)
	LD	(IX+%FFFFFFF6),A
;  281	
;  282			*output_ptr = ((r >> 6) & 0x03) | 
;  283	              (((g >> 6) & 0x03) << 2) | 
;  284	              (((b >> 6) & 0x03) << 4) | 
;  285	              (((a >> 6) & 0x03) << 6);	
.LINE 285

	LD	A,(IX+%FFFFFFF8)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	LD	B,A
	LD	A,(IX+%FFFFFFF7)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	LD	C,A
	LD	A,B
	OR	A,C
	LD	B,A
	LD	A,(IX+%FFFFFFF9)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	A,B
	OR	A,C
	LD	D,A
	LD	A,(IX+%FFFFFFF6)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	LD	B,%6
	CALL	__bshl
	LD	B,A
	LD	A,D
	OR	A,B
	LD	HL,(IX+%FFFFFFFA)
	LD	(HL),A
;  286			output_ptr++;
.LINE 286

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
;  287			
;  288	    }
L_72:
.LINE 288

	LD	HL,(IX+%C)
	LD	IY,(IX+%C)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%C),IY
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_73
;  289	}
.LINE 289

	LD	SP,IX
	POP	IX
	RET	


;**************************** _bgra8888_to_rgba2222 ***************************
;Name                         Addr/Register   Size   Type
;a                                    IX-10      1   variable
;r                                     IX-9      1   variable
;g                                     IX-8      1   variable
;b                                     IX-7      1   variable
;output_ptr                            IX-6      3   variable
;input_ptr                             IX-3      3   variable
;num_pixels                           IX+12      3   parameter
;output                                IX+9      3   parameter
;input                                 IX+6      3   parameter


; Stack Frame Size: 37 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "bgra8888_to_rgba2222",289,"_bgra8888_to_rgba2222"
;  290	
;  291	void generic8888_to_rgba2222(char *input, char *output, size_t num_pixels, uint8_t width, int8_t red_byte, int8_t green_byte, int8_t blue_byte, int8_t alpha_byte) {
_generic8888_to_rgba2222:
.DEFINE "_generic8888_to_rgba2222"

.VALUE _generic8888_to_rgba2222

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "generic8888_to_rgba2222",291,"_generic8888_to_rgba2222"

.LINE 291

.DEFINE "input"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "output"

.CLASS 65

.VALUE 9

.TYPE 34

.ENDEF

.DEFINE "num_pixels"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "width"

.CLASS 65

.VALUE 15

.TYPE 12

.ENDEF

.DEFINE "red_byte"

.CLASS 65

.VALUE 18

.TYPE 2

.ENDEF

.DEFINE "green_byte"

.CLASS 65

.VALUE 21

.TYPE 2

.ENDEF

.DEFINE "blue_byte"

.CLASS 65

.VALUE 24

.TYPE 2

.ENDEF

.DEFINE "alpha_byte"

.CLASS 65

.VALUE 27

.TYPE 2

.ENDEF

.DEFINE "input_ptr"

.CLASS 65

.VALUE -3

.TYPE 34

.ENDEF

.DEFINE "output_ptr"

.CLASS 65

.VALUE -6

.TYPE 34

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "g"

.CLASS 65

.VALUE -8

.TYPE 12

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -9

.TYPE 12

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE -10

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF3
	LD	SP,HL
;  292	    char *input_ptr = input;
.LINE 292

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
;  293	    char *output_ptr = output;
.LINE 293

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFFA),BC
;  294	
;  295	    while (num_pixels--) {
.LINE 295

	JR	L_81
L_82:
;  296	        uint8_t r = input_ptr[red_byte];
.LINE 296

	LD	A,(IX+%12)
	SEXT	HL
	LD	L,(IX+%12)
	LD	BC,(IX+%FFFFFFFD)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+%FFFFFFF9),A
;  297	        uint8_t g = input_ptr[green_byte];
.LINE 297

	LD	A,(IX+%15)
	SEXT	HL
	LD	L,(IX+%15)
	LD	BC,(IX+%FFFFFFFD)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+%FFFFFFF8),A
;  298	        uint8_t b = input_ptr[blue_byte];
.LINE 298

	LD	A,(IX+%18)
	SEXT	HL
	LD	L,(IX+%18)
	LD	BC,(IX+%FFFFFFFD)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+%FFFFFFF7),A
;  299	        uint8_t a = (alpha_byte < 0) ? 255 : input_ptr[alpha_byte];
.LINE 299

	LD	A,(IX+%1B)
	OR	A,A
	JP	P,L_78
	LD	BC,255
	LD	(IX+%FFFFFFF3),BC
	JR	L_79
L_78:
	LD	A,(IX+%1B)
	SEXT	HL
	LD	L,(IX+%1B)
	LD	BC,(IX+%FFFFFFFD)
	ADD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	(IX+%FFFFFFF3),HL
L_79:
	LD	A,(IX+%FFFFFFF3)
	LD	(IX+%FFFFFFF6),A
;  300	
;  301			*output_ptr = ((r >> 6) & 0x03) | 
;  302	              (((g >> 6) & 0x03) << 2) | 
;  303	              (((b >> 6) & 0x03) << 4) | 
;  304	              (((a >> 6) & 0x03) << 6);	
.LINE 304

	LD	A,(IX+%FFFFFFF8)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	A,(IX+%FFFFFFF9)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	LD	B,A
	LD	A,C
	OR	A,B
	LD	C,A
	LD	A,(IX+%FFFFFFF7)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	B,A
	LD	A,C
	OR	A,B
	LD	D,A
	LD	A,(IX+%FFFFFFF6)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	LD	B,%6
	CALL	__bshl
	LD	B,A
	LD	A,D
	OR	A,B
	LD	HL,(IX+%FFFFFFFA)
	LD	(HL),A
;  305			output_ptr++;
.LINE 305

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
;  306			
;  307			input_ptr += width;
.LINE 307

	LD	A,(IX+%F)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%FFFFFFFD)
	ADD	HL,BC
	LD	(IX+%FFFFFFFD),HL
;  308			
;  309	    }
L_81:
.LINE 309

	LD	HL,(IX+%C)
	LD	IY,(IX+%C)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%C),IY
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_82
;  310	}
.LINE 310

	LD	SP,IX
	POP	IX
	RET	


;**************************** _generic8888_to_rgba2222 ***************************
;Name                         Addr/Register   Size   Type
;temp76                               IX-13      3   variable
;a                                    IX-10      1   variable
;b                                     IX-9      1   variable
;g                                     IX-8      1   variable
;r                                     IX-7      1   variable
;output_ptr                            IX-6      3   variable
;input_ptr                             IX-3      3   variable
;alpha_byte                           IX+27      1   parameter
;blue_byte                            IX+24      1   parameter
;green_byte                           IX+21      1   parameter
;red_byte                             IX+18      1   parameter
;width                                IX+15      1   parameter
;num_pixels                           IX+12      3   parameter
;output                                IX+9      3   parameter
;input                                 IX+6      3   parameter


; Stack Frame Size: 43 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "generic8888_to_rgba2222",310,"_generic8888_to_rgba2222"
;  311	
;  312	int8_t getByte(uint32_t bitmask) {
_getByte:
.DEFINE "_getByte"

.VALUE _getByte

.CLASS 2

.TYPE 66

.ENDEF

.BEGFUNC "getByte",312,"_getByte"

.LINE 312

.DEFINE "bitmask"

.CLASS 65

.VALUE 6

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  313	
;  314	    if (bitmask & 0xFF) {
.LINE 314

	UEXT	HL
	LD	L,(IX+%6)
	LD	E,H
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_90
;  315	        return 0;
.LINE 315

	XOR	A,A
	JR	L_92
;  316	    }
;  317	    else if ((bitmask >> 8) & 0xFF) {
L_90:
.LINE 317

	LD	BC,(IX+%7)
	UEXT	HL
	LD	L,C
	LD	E,H
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_88
;  318	        return 1;
.LINE 318

	LD	A,%1
	JR	L_92
;  319	    }
;  320		else if ((bitmask >> 16) & 0xFF) {
L_88:
.LINE 320

	UEXT	HL
	PUSH	HL
	LD	BC,(IX+%7)
	PUSH	BC
	INC	SP
	POP	BC
	INC	SP
	INC	SP
	UEXT	HL
	LD	L,C
	LD	E,H
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_86
;  321	        return 2;
.LINE 321

	LD	A,%2
	JR	L_92
;  322	    }
;  323	    else if ((bitmask >> 24) & 0xFF) {
L_86:
.LINE 323

	LD	A,(IX+%9)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	UEXT	HL
	LD	L,C
	LD	E,H
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_91
;  324	        return 3;
.LINE 324

	LD	A,%3
	JR	L_92
;  325	    }
L_91:
.LINE 325

;  326	
;  327	    return -1;
.LINE 327

	LD	A,%FF
;  328	}
L_92:
.LINE 328

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getByte ***************************
;Name                         Addr/Register   Size   Type
;bitmask                               IX+6      4   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "getByte",328,"_getByte"
;  329	
;  330	void print_bin(void* value, size_t size) {
_print_bin:
.DEFINE "_print_bin"

.VALUE _print_bin

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "print_bin",330,"_print_bin"

.LINE 330

.DEFINE "value"

.CLASS 65

.VALUE 6

.TYPE 33

.ENDEF

.DEFINE "size"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "j"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
;  331	    
;  332		int i, j;
;  333		unsigned char* bytes = (unsigned char*)value;
;  334		
;  335		if (size == 0) {
.LINE 335

	LD	BC,0
	LD	HL,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_102
;  336	        printf("Error: Invalid size\n");
.LINE 336

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__54
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  337	        return;
.LINE 337

	JR	L_103
;  338	    }
L_102:
.LINE 338

;  339	
;  340	    for (i = size - 1; i >= 0; i--) {
.LINE 340

	LD	BC,(IX+%9)
	DEC	BC
	LD	(IX+%FFFFFFFD),BC
	JR	L_101
L_99:
;  341	        for (j = 7; j >= 0; j--) {
.LINE 341

	LD	BC,7
	LD	(IX+%FFFFFFFA),BC
	JR	L_98
L_96:
;  342	            printf("%d", (bytes[i] >> j) & 1);
.LINE 342

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%6)
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%FFFFFFFA)
	CALL	__ishrs
	LD	A,L
	AND	A,%1
	UEXT	HL
	LD	L,A
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,(IX+%FFFFFFFA)
	DEC	BC
	LD	(IX+%FFFFFFFA),BC
;  343	        }
L_98:
.LINE 343

	LD	BC,0
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JP	P,L__57
	JP	PE,L_96
	JR	L__58
L__57:
	JP	PO,L_96
L__58:
	LD	BC,(IX+%FFFFFFFD)
	DEC	BC
	LD	(IX+%FFFFFFFD),BC
;  344	    }
L_101:
.LINE 344

	LD	BC,0
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JP	P,L__59
	JP	PE,L_99
	JR	L__60
L__59:
	JP	PO,L_99
L__60:
;  345	}
L_103:
.LINE 345

	LD	SP,IX
	POP	IX
	RET	


;**************************** _print_bin ***************************
;Name                         Addr/Register   Size   Type
;__u_itoa                            IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;j                                     IX-6      3   variable
;i                                     IX-3      3   variable
;size                                  IX+9      3   parameter
;value                                 IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "print_bin",345,"_print_bin"
	SEGMENT STRSECT
L__54:
	DB	"Error: Invalid size"
	DB	10,0
	SEGMENT CODE
;  346	
;  347	bmp_info get_info(const char * filename) {
_get_info:
.DEFINE "_get_info"

.VALUE _get_info

.CLASS 2

.TAG "NONAME6"

.TYPE 72

.ENDEF

.BEGFUNC "get_info",347,"_get_info"

.LINE 347

.DEFINE "filename"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "main_header"

.CLASS 65

.VALUE -3

.TYPE 34

.ENDEF

.DEFINE "file"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "redmask"

.CLASS 65

.VALUE -6

.TYPE 13

.ENDEF

.DEFINE "greenmask"

.CLASS 65

.VALUE -8

.TYPE 13

.ENDEF

.DEFINE "bluemask"

.CLASS 65

.VALUE -10

.TYPE 13

.ENDEF

.DEFINE "alphamask"

.CLASS 65

.VALUE -12

.TYPE 13

.ENDEF

.DEFINE "fo"

.CLASS 65

.VALUE -15

.TAG "NONAME5"

.TYPE 40

.ENDEF

.DEFINE "initial_header"

.CLASS 65

.VALUE -33

.DIM 18

.TYPE 98

.ENDEF

.DEFINE "bmp"

.CLASS 65

.VALUE -1106

.TAG "NONAME6"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-1106
	ADD	HL,SP
	LD	SP,HL
;  348	
;  349		uint8_t file;
;  350		FIL * fo;
;  351		bmp_info bmp;
;  352		char initial_header[18];
;  353		char *main_header;
;  354		
;  355		memset(&bmp, 0, sizeof(bmp));	
.LINE 355

	LD	BC,1073
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	HL,IX
	LD	BC,-1106
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  356		
;  357		file = mos_fopen(filename, fa_read);
.LINE 357

	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),A
;  358		fo = (FIL * ) mos_getfil(file);
.LINE 358

	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_getfil
	POP	BC
	LD	(IX+%FFFFFFF1),HL
;  359		
;  360	    if (!file) {
.LINE 360

	LD	A,(IX+%FFFFFFFC)
	OR	A,A
	JR	NZ,L_105
;  361	        printf("Error: could not open %s.\r\n", filename);
.LINE 361

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__63
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__64
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  362	        return bmp;
.LINE 362

	LEA	HL,IX+%6
	LD	DE,(HL)
	LD	HL,IX
	LD	BC,-1106
	ADD	HL,BC
	LD	BC,1073
	LDIR	
	LD	HL,(IX+%6)
	JR	L_122
;  363	    }
L_105:
.LINE 363

;  364	
;  365		mos_fread(file, initial_header, 14 + 4); //14 Bytes for core header, 4 bytes for full header size
.LINE 365

	LD	BC,18
	PUSH	BC
	PEA	IX+%FFFFFFDF
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  366		
;  367		bmp.pixels_offset = * (uint32_t * ) & initial_header[10];
.LINE 367

	LEA	HL,IX+%FFFFFFE9
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1101
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  368	    bmp.main_header_size = * (uint32_t * ) & initial_header[14];
.LINE 368

	LEA	HL,IX+%FFFFFFED
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1093
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  369		
;  370		main_header = malloc(bmp.main_header_size);
.LINE 370

	LD	HL,-1093
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFFD),HL
;  371		
;  372		mos_flseek(file, 14);
.LINE 372

	LD	BC,0
	PUSH	BC
	LD	BC,14
	PUSH	BC
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  373		mos_fread(file, main_header, bmp.main_header_size);
.LINE 373

	LD	HL,-1093
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  374		
;  375		bmp.bmp_width = *(int32_t *) & main_header[4];
.LINE 375

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%4
	LD	BC,(HL)
	LD	HL,-1106
	LD	DE,IX
	ADD	HL,DE
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  376		bmp.bmp_height = *(int32_t *) & main_header[8];
.LINE 376

	LEA	HL,IY+%8
	LD	BC,(HL)
	LD	HL,-1104
	LD	DE,IX
	ADD	HL,DE
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  377		bmp.bmp_bitdepth = *(uint16_t *) & main_header[14];	
.LINE 377

	LEA	HL,IY+%E
	LD	A,(HL)
	LD	HL,-1102
	LD	BC,IX
	ADD	HL,BC
	LD	(HL),A
;  378		bmp.compression = *(uint32_t *) & main_header[16];
.LINE 378

	LEA	HL,IY+%10
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1089
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  379		bmp.color_table_size = * (uint32_t * ) & main_header[32];
.LINE 379

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%20
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1069
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  380	
;  381	    if (bmp.color_table_size == 0 && bmp.bmp_bitdepth == 8) {
.LINE 381

	LD	IY,-1069
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_109
	LD	HL,-1102
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%8
	JR	NZ,L_109
;  382	        bmp.color_table_size = 256;
.LINE 382

	LD	BC,256
	LD	IY,-1069
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),%0
;  383	    }
L_109:
.LINE 383

;  384	
;  385		if (bmp.color_table_size > 0) mos_fread(file, bmp.color_table, bmp.color_table_size * 4);
.LINE 385

	LD	IY,-1069
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	OR	A,A
	SBC	HL,HL
	LD	E,%0
	CALL	__lcmpu
	JR	NC,L_110
	LD	HL,-1069
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	LD	HL,IX
	LD	BC,-1065
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
L_110:
;  386		
;  387		bmp.row_padding = (4 - (bmp.bmp_width * (bmp.bmp_bitdepth / 8)) % 4) % 4;
.LINE 387

	LD	HL,-1106
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1102
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,8
	CALL	__idivs
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,4
	CALL	__irems
	LD	BC,HL
	LD	HL,4
	OR	A,A
	SBC	HL,BC
	LD	BC,4
	CALL	__irems
	LD	(IX+%FFFFFFDB),L
	LD	(IX+%FFFFFFDC),H
;  388		bmp.non_pad_row = bmp.bmp_width * bmp.bmp_bitdepth / 8;
.LINE 388

	LD	HL,-1106
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1102
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,8
	CALL	__idivs
	LD	(IX+%FFFFFFDD),L
	LD	(IX+%FFFFFFDE),H
;  389		
;  390		printf("Debug: BMP is %u x %u x %u, compression type %u, and DIB size %u\r\n", bmp.bmp_width, bmp.bmp_height, bmp.bmp_bitdepth, bmp.compression, bmp.main_header_size);
.LINE 390

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__68
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	HL,-1106
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__69
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	HL,-1104
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__70
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	HL,-1102
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__71
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	IY,-1089
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__72
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	IY,-1093
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__73
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  391	
;  392		if ((bmp.compression == 3) || (bmp.compression == 6) && bmp.main_header_size >= 108) {
.LINE 392

	LD	IY,-1089
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,3
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_120
	LD	IY,-1089
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,6
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_121
	LD	IY,-1093
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,108
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_121
L_120:
;  393			
;  394			if (bmp.bmp_bitdepth == 32) {
.LINE 394

	LD	HL,-1102
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%20
	JR	NZ,L_119
;  395								
;  396				bmp.redBitField = *(uint32_t *) & main_header[40];
.LINE 396

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%28
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1085
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  397				bmp.red_pos = getByte(bmp.redBitField);
.LINE 397

	LD	IY,-1085
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFD7),A
;  398				
;  399				bmp.greenBitField = *(uint32_t *) & main_header[44];
.LINE 399

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%2C
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1081
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  400				bmp.green_pos = getByte(bmp.greenBitField);
.LINE 400

	LD	IY,-1081
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFD8),A
;  401				
;  402				bmp.blueBitField = *(uint32_t *) & main_header[48];
.LINE 402

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%30
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1077
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  403				bmp.blue_pos = getByte(bmp.blueBitField);
.LINE 403

	LD	IY,-1077
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFD9),A
;  404				
;  405				bmp.alphaBitField = *(uint32_t *) & main_header[52];			
.LINE 405

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%34
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1073
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  406				bmp.alpha_pos = getByte(bmp.alphaBitField);
.LINE 406

	LD	IY,-1073
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFDA),A
;  407				
;  408				printf("Red bitfield:   "); print_bin(&bmp.redBitField, sizeof(bmp.redBitField));	printf(" (byte %u in pixel)\r\n", bmp.red_pos);
.LINE 408

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__78
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,4
	PUSH	BC
	LD	HL,IX
	LD	BC,-1085
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_print_bin
	POP	BC
	POP	BC
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__79
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	A,(IX+%FFFFFFD7)
	SEXT	HL
	LD	L,(IX+%FFFFFFD7)
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__80
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  409				printf("Green bitfield: "); print_bin(&bmp.greenBitField, sizeof(bmp.greenBitField));	printf(" (byte %u in pixel)\r\n", bmp.green_pos);
.LINE 409

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__81
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,4
	PUSH	BC
	LD	HL,IX
	LD	BC,-1081
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_print_bin
	POP	BC
	POP	BC
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__82
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	A,(IX+%FFFFFFD8)
	SEXT	HL
	LD	L,(IX+%FFFFFFD8)
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__83
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  410				printf("Blue bitfield:  "); print_bin(&bmp.blueBitField, sizeof(bmp.blueBitField));	printf(" (byte %u in pixel)\r\n", bmp.blue_pos);
.LINE 410

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__84
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,4
	PUSH	BC
	LD	HL,IX
	LD	BC,-1077
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_print_bin
	POP	BC
	POP	BC
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__85
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	A,(IX+%FFFFFFD9)
	SEXT	HL
	LD	L,(IX+%FFFFFFD9)
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__86
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  411	
;  412				if (bmp.alpha_pos == -1) printf("No alpha channel\r\n");
.LINE 412

	LD	A,(IX+%FFFFFFDA)
	CP	A,%FFFFFFFF
	JR	NZ,L_114
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__88
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  413				else { printf("Alpha bitfield: "); print_bin(&bmp.alphaBitField, sizeof(bmp.alphaBitField)); printf(" (byte %u in pixel)\r\n", bmp.alpha_pos); }
.LINE 413

	JR	L_121
L_114:
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__89
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,4
	PUSH	BC
	LD	HL,IX
	LD	BC,-1073
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_print_bin
	POP	BC
	POP	BC
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__90
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%75
	LD	(___print_fmt+4),A
	LD	A,(IX+%FFFFFFDA)
	SEXT	HL
	LD	L,(IX+%FFFFFFDA)
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__91
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  414						
;  415			} else if (bmp.bmp_bitdepth == 16) {
.LINE 415

	JR	L_121
L_119:
	LD	HL,-1102
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%10
	JR	NZ,L_121
;  416				
;  417				uint16_t redmask, greenmask, bluemask, alphamask;
;  418				
;  419				bmp.redBitField = *(uint32_t *) & main_header[40];
.LINE 419

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%28
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1085
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  420				redmask = (uint16_t)(bmp.redBitField & 0xFFFF);
.LINE 420

	LD	HL,-1085
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	LD	(IX+%FFFFFFFA),L
	LD	(IX+%FFFFFFFB),H
;  421				
;  422				bmp.greenBitField = *(uint32_t *) & main_header[44];
.LINE 422

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%2C
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1081
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  423				greenmask = (uint16_t)(bmp.greenBitField & 0xFFFF);
.LINE 423

	LD	HL,-1081
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	LD	(IX+%FFFFFFF8),L
	LD	(IX+%FFFFFFF9),H
;  424				
;  425				bmp.blueBitField = *(uint32_t *) & main_header[48];
.LINE 425

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%30
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1077
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  426				bluemask = (uint16_t)(bmp.blueBitField & 0xFFFF);
.LINE 426

	LD	HL,-1077
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	LD	(IX+%FFFFFFF6),L
	LD	(IX+%FFFFFFF7),H
;  427				
;  428				bmp.alphaBitField = *(uint32_t *) & main_header[52];			
.LINE 428

	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%34
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1073
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  429				alphamask = (uint16_t)(bmp.alphaBitField & 0xFFFF);
.LINE 429

	LD	HL,-1073
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	LD	(IX+%FFFFFFF4),L
	LD	(IX+%FFFFFFF5),H
;  430				
;  431				printf("Red bitfield:   "); print_bin(&redmask, sizeof(redmask));
.LINE 431

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__93
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,2
	PUSH	BC
	PEA	IX+%FFFFFFFA
	CALL	_print_bin
	POP	BC
	POP	BC
;  432				printf("\r\nGreen bitfield: "); print_bin(&greenmask, sizeof(greenmask));
.LINE 432

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__94
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,2
	PUSH	BC
	PEA	IX+%FFFFFFF8
	CALL	_print_bin
	POP	BC
	POP	BC
;  433				printf("\r\nBlue bitfield:  "); print_bin(&bluemask, sizeof(bluemask));
.LINE 433

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__95
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,2
	PUSH	BC
	PEA	IX+%FFFFFFF6
	CALL	_print_bin
	POP	BC
	POP	BC
;  434	
;  435				if (bmp.alphaBitField == 0) printf("\r\nNo alpha channel\r\n");
.LINE 435

	LD	IY,-1073
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_116
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__97
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  436				else { printf("\r\nAlpha bitfield: "); print_bin(&alphamask, sizeof(alphamask)); printf("\r\n");}		
.LINE 436

	JR	L_121
L_116:
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__98
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,2
	PUSH	BC
	PEA	IX+%FFFFFFF4
	CALL	_print_bin
	POP	BC
	POP	BC
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__99
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  437				
;  438			}
;  439			
;  440			
;  441		}
L_121:
.LINE 441

;  442		
;  443		mos_fclose(file);
.LINE 443

	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  444		return bmp;
.LINE 444

	LEA	HL,IX+%6
	LD	DE,(HL)
	LD	HL,IX
	LD	BC,-1106
	ADD	HL,BC
	LD	BC,1073
	LDIR	
	LD	HL,(IX+%6)
;  445	
;  446	}
L_122:
.LINE 446

	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_info ***************************
;Name                         Addr/Register   Size   Type
;_mos_fclose                         IMPORT  -----   function
;__u_uitoa                           IMPORT  -----   function
;___print_fmt                        IMPORT     19   variable
;_mos_flseek                         IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;_mos_fread                          IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_mos_getfil                         IMPORT  -----   function
;_mos_fopen                          IMPORT  -----   function
;_memset                             IMPORT  -----   function
;bmp                                IX-1106   1073   variable
;initial_header                       IX-33     18   variable
;fo                                   IX-15      3   variable
;alphamask                            IX-12      2   variable
;bluemask                             IX-10      2   variable
;greenmask                             IX-8      2   variable
;redmask                               IX-6      2   variable
;file                                  IX-4      1   variable
;main_header                           IX-3      3   variable
;filename                              IX+9      3   parameter


; Stack Frame Size: 1118 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "get_info",446,"_get_info"
	SEGMENT STRSECT
L__63:
	DB	"Error: could not open "
	DB	0
L__64:
	DB	"."
	DB	13,10,0
L__68:
	DB	"Debug: BMP is "
	DB	0
L__69:
	DB	" x "
	DB	0
L__70:
	DB	" x "
	DB	0
L__71:
	DB	", compression type "
	DB	0
L__72:
	DB	", and DIB size "
	DB	0
L__73:
	DB	13,10,0
L__78:
	DB	"Red bitfield:   "
	DB	0
L__79:
	DB	" (byte "
	DB	0
L__80:
	DB	" in pixel)"
	DB	13,10,0
L__81:
	DB	"Green bitfield: "
	DB	0
L__82:
	DB	" (byte "
	DB	0
L__83:
	DB	" in pixel)"
	DB	13,10,0
L__84:
	DB	"Blue bitfield:  "
	DB	0
L__85:
	DB	" (byte "
	DB	0
L__86:
	DB	" in pixel)"
	DB	13,10,0
L__88:
	DB	"No alpha channel"
	DB	13,10,0
L__89:
	DB	"Alpha bitfield: "
	DB	0
L__90:
	DB	" (byte "
	DB	0
L__91:
	DB	" in pixel)"
	DB	13,10,0
L__93:
	DB	"Red bitfield:   "
	DB	0
L__94:
	DB	13,10
	DB	"Green bitfield: "
	DB	0
L__95:
	DB	13,10
	DB	"Blue bitfield:  "
	DB	0
L__97:
	DB	13,10
	DB	"No alpha channel"
	DB	13,10,0
L__98:
	DB	13,10
	DB	"Alpha bitfield: "
	DB	0
L__99:
	DB	13,10,0
	SEGMENT CODE
;  447	
;  448	bmp_info load_bmp_clean(const char * filename, UINT8 slot) {
_load_bmp_clean:
.DEFINE "_load_bmp_clean"

.VALUE _load_bmp_clean

.CLASS 2

.TAG "NONAME6"

.TYPE 72

.ENDEF

.BEGFUNC "load_bmp_clean",448,"_load_bmp_clean"

.LINE 448

.DEFINE "filename"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "slot"

.CLASS 65

.VALUE 12

.TYPE 12

.ENDEF

.DEFINE "file"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "main_header"

.CLASS 65

.VALUE -4

.TYPE 34

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -6

.TYPE 3

.ENDEF

.DEFINE "row_rgba2222"

.CLASS 65

.VALUE -9

.TYPE 34

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -11

.TYPE 3

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -13

.TYPE 3

.ENDEF

.DEFINE "fo"

.CLASS 65

.VALUE -16

.TAG "NONAME5"

.TYPE 40

.ENDEF

.DEFINE "src"

.CLASS 65

.VALUE -19

.TYPE 34

.ENDEF

.DEFINE "index"

.CLASS 65

.VALUE -20

.TYPE 12

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -21

.TYPE 12

.ENDEF

.DEFINE "g"

.CLASS 65

.VALUE -22

.TYPE 12

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -23

.TYPE 12

.ENDEF

.DEFINE "src"

.CLASS 65

.VALUE -26

.TYPE 34

.ENDEF

.DEFINE "initial_header"

.CLASS 65

.VALUE -44

.DIM 18

.TYPE 98

.ENDEF

.DEFINE "bmp"

.CLASS 65

.VALUE -1117

.TAG "NONAME6"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-1135
	ADD	HL,SP
	LD	SP,HL
;  449		
;  450		uint8_t file;
;  451		FIL * fo;
;  452		bmp_info bmp;
;  453		char initial_header[18];
;  454		char *main_header;
;  455		char * row_rgba2222;
;  456		int16_t y = 0;
;  457		
;  458		memset(&bmp, 0, sizeof(bmp));	
.LINE 458

	LD	BC,1073
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	HL,IX
	LD	BC,-1117
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  459		
;  460		file = mos_fopen(filename, fa_read);
.LINE 460

	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFF),A
;  461		fo = (FIL * ) mos_getfil(file);
.LINE 461

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_getfil
	POP	BC
	LD	(IX+%FFFFFFF0),HL
;  462		
;  463	    if (!file) {
.LINE 463

	LD	A,(IX+%FFFFFFFF)
	OR	A,A
	JR	NZ,L_124
;  464	        printf("Error: could not open %s.\r\n", filename);
.LINE 464

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__102
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__103
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  465	        return bmp;
.LINE 465

	LEA	HL,IX+%6
	LD	DE,(HL)
	LD	HL,IX
	LD	BC,-1117
	ADD	HL,BC
	LD	BC,1073
	LDIR	
	LD	HL,(IX+%6)
	JR	L_166
;  466	    }
L_124:
.LINE 466

;  467	
;  468		mos_fread(file, initial_header, 14 + 4); //14 Bytes for core header, 4 bytes for full header size
.LINE 468

	LD	BC,18
	PUSH	BC
	PEA	IX+%FFFFFFD4
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  469		
;  470		bmp.pixels_offset = * (uint32_t * ) & initial_header[10];
.LINE 470

	LEA	HL,IX+%FFFFFFDE
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1112
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  471	    bmp.main_header_size = * (uint32_t * ) & initial_header[14];
.LINE 471

	LEA	HL,IX+%FFFFFFE2
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1104
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  472		
;  473		main_header = malloc(bmp.main_header_size);
.LINE 473

	LD	HL,-1104
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFFC),HL
;  474		
;  475		mos_flseek(file, 14);
.LINE 475

	LD	BC,0
	PUSH	BC
	LD	BC,14
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  476		mos_fread(file, main_header, bmp.main_header_size);
.LINE 476

	LD	HL,-1104
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  477		
;  478		bmp.bmp_width = *(int32_t *) & main_header[4];
.LINE 478

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%4
	LD	BC,(HL)
	LD	HL,-1117
	LD	DE,IX
	ADD	HL,DE
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  479		bmp.bmp_height = *(int32_t *) & main_header[8];
.LINE 479

	LEA	HL,IY+%8
	LD	BC,(HL)
	LD	HL,-1115
	LD	DE,IX
	ADD	HL,DE
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  480		bmp.bmp_bitdepth = *(uint16_t *) & main_header[14];	
.LINE 480

	LEA	HL,IY+%E
	LD	A,(HL)
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	(HL),A
;  481		bmp.compression = *(uint32_t *) & main_header[16];
.LINE 481

	LEA	HL,IY+%10
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1100
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  482		bmp.color_table_size = * (uint32_t * ) & main_header[32];
.LINE 482

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%20
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1080
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  483	
;  484	    if (bmp.color_table_size == 0 && bmp.bmp_bitdepth == 8) {
.LINE 484

	LD	IY,-1080
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_128
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%8
	JR	NZ,L_128
;  485	        bmp.color_table_size = 256;
.LINE 485

	LD	BC,256
	LD	IY,-1080
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),%0
;  486	    }
L_128:
.LINE 486

;  487	
;  488		if (bmp.color_table_size > 0) mos_fread(file, bmp.color_table, bmp.color_table_size * 4);
.LINE 488

	LD	IY,-1080
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	OR	A,A
	SBC	HL,HL
	LD	E,%0
	CALL	__lcmpu
	JR	NC,L_129
	LD	HL,-1080
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	LD	HL,IX
	LD	BC,-1076
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
L_129:
;  489		
;  490		bmp.row_padding = (4 - (bmp.bmp_width * (bmp.bmp_bitdepth / 8)) % 4) % 4;
.LINE 490

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,8
	CALL	__idivs
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,4
	CALL	__irems
	LD	BC,HL
	LD	HL,4
	OR	A,A
	SBC	HL,BC
	LD	BC,4
	CALL	__irems
	LD	(IX+%FFFFFFD0),L
	LD	(IX+%FFFFFFD1),H
;  491		bmp.non_pad_row = bmp.bmp_width * bmp.bmp_bitdepth / 8;
.LINE 491

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,8
	CALL	__idivs
	LD	(IX+%FFFFFFD2),L
	LD	(IX+%FFFFFFD3),H
;  492		row_rgba2222 = (char * ) malloc(bmp.bmp_width);
.LINE 492

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFF7),HL
;  493		
;  494		if ((bmp.compression != 0) && (bmp.compression != 3)) {
.LINE 494

	LD	IY,-1100
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_164
	LD	IY,-1100
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,3
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_164
;  495			printf("Non standard BMP compression, exiting.\r\n");
.LINE 495

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__109
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  496			return bmp;
.LINE 496

	LEA	HL,IX+%6
	LD	DE,(HL)
	LD	HL,IX
	LD	BC,-1117
	ADD	HL,BC
	LD	BC,1073
	LDIR	
	LD	HL,(IX+%6)
	JR	L_166
;  497		}
L_164:
.LINE 497

;  498		
;  499		if ((bmp.compression == 3) || (bmp.compression == 6) && bmp.main_header_size >= 108) {
.LINE 499

	LD	IY,-1100
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,3
	XOR	A,A
	CALL	__lcmpu
	JR	Z,L_162
	LD	IY,-1100
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,6
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_163
	LD	IY,-1104
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,108
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_163
L_162:
;  500			
;  501			if (bmp.bmp_bitdepth == 16) {
.LINE 501

	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%10
	JR	NZ,L_141
;  502				
;  503				printf("16-bit BMP files not supported, use 8-bit (small), 24-bit (fast) or 32-bit (alpha-enabled).\r\n");
.LINE 503

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__114
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  504				return bmp;
.LINE 504

	LEA	HL,IX+%6
	LD	DE,(HL)
	LD	HL,IX
	LD	BC,-1117
	ADD	HL,BC
	LD	BC,1073
	LDIR	
	LD	HL,(IX+%6)
	JR	L_166
;  505	
;  506			} else if (bmp.bmp_bitdepth == 32) {
L_141:
.LINE 506

	LD	HL,-1113
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%20
	JR	NZ,L_165
;  507						
;  508				char * src;
;  509				
;  510				bmp.redBitField = *(uint32_t *) & main_header[40];
.LINE 510

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%28
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1096
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  511				bmp.red_pos = getByte(bmp.redBitField);
.LINE 511

	LD	IY,-1096
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFCC),A
;  512				bmp.greenBitField = *(uint32_t *) & main_header[44];
.LINE 512

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%2C
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1092
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  513				bmp.green_pos = getByte(bmp.greenBitField);
.LINE 513

	LD	IY,-1092
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFCD),A
;  514				bmp.blueBitField = *(uint32_t *) & main_header[48];
.LINE 514

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%30
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1088
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  515				bmp.blue_pos = getByte(bmp.blueBitField);
.LINE 515

	LD	IY,-1088
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFCE),A
;  516				bmp.alphaBitField = *(uint32_t *) & main_header[52];			
.LINE 516

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%34
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	IY,-1084
	LD	DE,IX
	ADD	IY,DE
	LD	(IY),BC
	LD	(IY+%3),A
;  517				bmp.alpha_pos = getByte(bmp.alphaBitField);
.LINE 517

	LD	IY,-1084
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+%3)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_getByte
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFCF),A
;  518				
;  519			    src = (char * ) malloc(bmp.bmp_width * bmp.bmp_bitdepth / 8);
.LINE 519

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,8
	CALL	__idivs
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFED),HL
;  520				mos_flseek(file, bmp.pixels_offset + ((bmp.bmp_height - 1) * (bmp.non_pad_row + bmp.row_padding)));
.LINE 520

	LD	HL,-1115
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	DEC	DE
	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,BC
	LD	BC,-1135	; spill
	CALL	__istix
	LD	BC,(IX+%FFFFFFD0)
	CALL	__stoiu
	LD	BC,-1135	; unspill
	PUSH	HL
	CALL	__ildix
	LD	BC,HL
	POP	HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,HL
	CALL	__itol
	LD	IY,-1112
	LD	DE,IX
	ADD	IY,DE
	LD	HL,(IY)
	LD	E,(IY+%3)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  521				clear_buffer(slot);
.LINE 521

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_clear_buffer
	POP	BC
;  522	
;  523				for (y = bmp.bmp_height - 1; y >= 0; y--) {
.LINE 523

	LD	HL,-1115
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	DEC	HL
	LD	(IX+%FFFFFFFA),L
	LD	(IX+%FFFFFFFB),H
	JR	L_137
L_135:
;  524	
;  525					//printf("Row: %u\r\n",y);
;  526					mos_fread(file, src, bmp.non_pad_row);
.LINE 526

	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	PUSH	HL
	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  527					generic8888_to_rgba2222(src, row_rgba2222,bmp.bmp_width,bmp.bmp_bitdepth / 8,bmp.red_pos,bmp.green_pos,bmp.blue_pos,bmp.alpha_pos);
.LINE 527

	LD	C,(IX+%FFFFFFCF)
	LD	B,%0
	PUSH	BC
	LD	C,(IX+%FFFFFFCE)
	PUSH	BC
	LD	C,(IX+%FFFFFFCD)
	PUSH	BC
	LD	C,(IX+%FFFFFFCC)
	PUSH	BC
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,8
	CALL	__idivs
	LD	C,L
	LD	B,%0
	PUSH	BC
	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	PUSH	HL
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	CALL	_generic8888_to_rgba2222
	LD	IY,24
	ADD	IY,SP
	LD	SP,IY
;  528					add_stream_to_buffer(slot,row_rgba2222,bmp.bmp_width);
.LINE 528

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_add_stream_to_buffer
	POP	BC
	POP	BC
	POP	BC
;  529					mos_flseek(file, fo -> fptr - ((bmp.non_pad_row * 2) + bmp.row_padding));
.LINE 529

	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	ADD	HL,HL
	LD	DE,HL
	LD	BC,(IX+%FFFFFFD0)
	CALL	__stoiu
	ADD	HL,DE
	LD	BC,HL
	CALL	__itol
	LD	IY,(IX+%FFFFFFF0)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	CALL	__lsub
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
	LD	HL,(IX+%FFFFFFFA)
	DEC	HL
	LD	(IX+%FFFFFFFA),L
	LD	(IX+%FFFFFFFB),H
;  530	
;  531				}
L_137:
.LINE 531

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC.SIS	HL,BC
	JP	P,L_135
;  532				free(src);
.LINE 532

	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	CALL	_free
	POP	BC
;  533				
;  534			}
;  535			
;  536		} else if (bmp.compression == 0) {
.LINE 536

	JR	L_165
L_163:
	LD	IY,-1100
	LD	BC,IX
	ADD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_165
;  537	
;  538			if (bmp.bmp_bitdepth == 16) {
.LINE 538

	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%10
	JR	NZ,L_153
;  539				
;  540				printf("16-bit BMP files not supported, use 8-bit (small), 24-bit (fast) or 32-bit (alpha-enabled).\r\n");
.LINE 540

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__119
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  541				return bmp;
.LINE 541

	LEA	HL,IX+%6
	LD	DE,(HL)
	LD	HL,IX
	LD	BC,-1117
	ADD	HL,BC
	LD	BC,1073
	LDIR	
	LD	HL,(IX+%6)
	JR	L_166
;  542				
;  543			} else if (bmp.bmp_bitdepth == 8) {
L_153:
.LINE 543

	LD	HL,-1113
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%8
	JR	NZ,L_160
;  544				
;  545				int16_t x,y;
;  546				uint8_t index, b, g, r;
;  547	
;  548				mos_flseek(file, bmp.pixels_offset + ((bmp.bmp_height - 1) * (bmp.non_pad_row + bmp.row_padding)));
.LINE 548

	LD	HL,-1115
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	DEC	DE
	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,BC
	LD	BC,-1132	; spill
	CALL	__istix
	LD	BC,(IX+%FFFFFFD0)
	CALL	__stoiu
	LD	BC,-1132	; unspill
	PUSH	HL
	CALL	__ildix
	LD	BC,HL
	POP	HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,HL
	CALL	__itol
	LD	IY,-1112
	LD	DE,IX
	ADD	IY,DE
	LD	HL,(IY)
	LD	E,(IY+%3)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  549				clear_buffer(slot);
.LINE 549

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_clear_buffer
	POP	BC
;  550				
;  551				for (y = bmp.bmp_height - 1; y >= 0; y--) {
.LINE 551

	LD	HL,-1115
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	DEC	HL
	LD	(IX+%FFFFFFF3),L
	LD	(IX+%FFFFFFF4),H
	JR	L_150
L_148:
;  552					for (x = 0; x < bmp.bmp_width; x++) {
.LINE 552

	LD	(IX+%FFFFFFF5),%0
	LD	(IX+%FFFFFFF6),%0
	JR	L_146
L_144:
;  553	
;  554						index = (char) mos_fgetc(file);
.LINE 554

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fgetc
	POP	BC
	LD	(IX+%FFFFFFEC),A
;  555						b = bmp.color_table[index * 4];
.LINE 555

	LD	IY,IX
	LD	BC,-1076
	ADD	IY,BC
	LD	HL,-1123
	LD	BC,IX
	ADD	HL,BC
	LD	(HL),IY
	LD	A,(IX+%FFFFFFEC)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	IY,-1123
	LD	BC,IX
	ADD	IY,BC
	LD	BC,(IY)
	ADD	HL,BC
	LD	IY,-1120
	LD	BC,IX
	ADD	IY,BC
	LD	(IY),HL
	LD	HL,-1120
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	LD	A,(HL)
	LD	(IX+%FFFFFFEB),A
;  556						g = bmp.color_table[index * 4 + 1];
.LINE 556

	LD	HL,-1120
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFEA),A
;  557						r = bmp.color_table[index * 4 + 2];
.LINE 557

	LD	HL,-1120
	LD	BC,IX
	ADD	HL,BC
	LD	IY,(HL)
	LEA	HL,IY+%2
	LD	A,(HL)
	LD	(IX+%FFFFFFE9),A
;  558						
;  559						row_rgba2222[x] = 	(((r >> 6) & 0x03) | 
;  560											(((g >> 6) & 0x03) << 2) | 
;  561											(((b >> 6) & 0x03) << 4) | 
;  562											0xC0);
.LINE 562

	LD	A,(IX+%FFFFFFEA)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	LD	B,A
	LD	A,(IX+%FFFFFFE9)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	LD	C,A
	LD	A,B
	OR	A,C
	LD	B,A
	LD	A,(IX+%FFFFFFEB)
	UEXT	HL
	LD	L,A
	LD	A,%6
	CALL	__ishrs_b
	LD	A,L
	AND	A,%3
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	C,A
	LD	A,B
	OR	A,C
	OR	A,%C0
	LD	BC,(IX+%FFFFFFF5)
	CALL	__stoi
	LD	BC,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	(HL),A
	LD	HL,(IX+%FFFFFFF5)
	INC	HL
	LD	(IX+%FFFFFFF5),L
	LD	(IX+%FFFFFFF6),H
;  563						
;  564	
;  565					}
L_146:
.LINE 565

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	LD	BC,(IX+%FFFFFFF5)
	CALL	__stoi
	OR	A,A
	SBC	HL,DE
	JP	M,L__125
	JP	PE,L_144
	JR	L__126
L__125:
	JP	PO,L_144
L__126:
;  566					
;  567					add_stream_to_buffer(slot,row_rgba2222,bmp.bmp_width);
.LINE 567

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_add_stream_to_buffer
	POP	BC
	POP	BC
	POP	BC
;  568					mos_flseek(file, fo -> fptr - ((bmp.non_pad_row * 2) + bmp.row_padding));
.LINE 568

	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	ADD	HL,HL
	LD	DE,HL
	LD	BC,(IX+%FFFFFFD0)
	CALL	__stoiu
	ADD	HL,DE
	LD	BC,HL
	CALL	__itol
	LD	IY,(IX+%FFFFFFF0)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	CALL	__lsub
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
	LD	HL,(IX+%FFFFFFF3)
	DEC	HL
	LD	(IX+%FFFFFFF3),L
	LD	(IX+%FFFFFFF4),H
;  569	
;  570				}
L_150:
.LINE 570

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFF3)
	OR	A,A
	SBC.SIS	HL,BC
	JP	P,L__127
	JP	PE,L_148
	JR	L__128
L__127:
	JP	PO,L_148
L__128:
;  571	
;  572			}
L_160:
.LINE 572

;  573			
;  574			if (bmp.bmp_bitdepth == 24) {
.LINE 574

	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%18
	JR	NZ,L_165
;  575			
;  576				//uint16_t new_row_size;
;  577				
;  578			    char * src = (char * ) malloc(bmp.bmp_width * bmp.bmp_bitdepth / 8);
.LINE 578

	LD	HL,-1117
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,8
	CALL	__idivs
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFE6),HL
;  579				mos_flseek(file, bmp.pixels_offset + ((bmp.bmp_height - 1) * (bmp.non_pad_row + bmp.row_padding)));
.LINE 579

	LD	HL,-1115
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	DEC	DE
	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,BC
	LD	BC,-1129	; spill
	CALL	__istix
	LD	BC,(IX+%FFFFFFD0)
	CALL	__stoiu
	LD	BC,-1129	; unspill
	PUSH	HL
	CALL	__ildix
	LD	BC,HL
	POP	HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	BC,HL
	CALL	__itol
	LD	IY,-1112
	LD	DE,IX
	ADD	IY,DE
	LD	HL,(IY)
	LD	E,(IY+%3)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  580				clear_buffer(slot);
.LINE 580

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_clear_buffer
	POP	BC
;  581				
;  582				for (y = bmp.bmp_height - 1; y >= 0; y--) {
.LINE 582

	LD	HL,-1115
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	DEC	HL
	LD	(IX+%FFFFFFFA),L
	LD	(IX+%FFFFFFFB),H
	JR	L_157
L_155:
;  583	
;  584					mos_fread(file, src, bmp.non_pad_row);
.LINE 584

	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	PUSH	HL
	LD	BC,(IX+%FFFFFFE6)
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  585					generic8888_to_rgba2222(src, row_rgba2222,bmp.bmp_width,bmp.bmp_bitdepth / 8,2,1,0,-1);
.LINE 585

	LD	BC,16777215
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	HL,-1113
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,8
	CALL	__idivs
	LD	C,L
	LD	B,%0
	PUSH	BC
	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	PUSH	HL
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	BC,(IX+%FFFFFFE6)
	PUSH	BC
	CALL	_generic8888_to_rgba2222
	LD	IY,24
	ADD	IY,SP
	LD	SP,IY
;  586					add_stream_to_buffer(slot,row_rgba2222,bmp.bmp_width);
.LINE 586

	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_add_stream_to_buffer
	POP	BC
	POP	BC
	POP	BC
;  587					mos_flseek(file, fo -> fptr - ((bmp.non_pad_row * 2) + bmp.row_padding));
.LINE 587

	LD	BC,(IX+%FFFFFFD2)
	CALL	__stoiu
	ADD	HL,HL
	LD	DE,HL
	LD	BC,(IX+%FFFFFFD0)
	CALL	__stoiu
	ADD	HL,DE
	LD	BC,HL
	CALL	__itol
	LD	IY,(IX+%FFFFFFF0)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	CALL	__lsub
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
	LD	HL,(IX+%FFFFFFFA)
	DEC	HL
	LD	(IX+%FFFFFFFA),L
	LD	(IX+%FFFFFFFB),H
;  588	
;  589				}		
L_157:
.LINE 589

	LD.LIS	BC,0
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC.SIS	HL,BC
	JP	P,L__129
	JP	PE,L_155
	JR	L__130
L__129:
	JP	PO,L_155
L__130:
;  590				free(src);
.LINE 590

	LD	BC,(IX+%FFFFFFE6)
	PUSH	BC
	CALL	_free
	POP	BC
;  591			
;  592			}
;  593		}
L_165:
.LINE 593

;  594		
;  595		assign_buffer_to_bitmap(slot,1,bmp.bmp_width,bmp.bmp_height);
.LINE 595

	LD	HL,-1115
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	HL,-1117
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_assign_buffer_to_bitmap
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  596		free(row_rgba2222);
.LINE 596

	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	CALL	_free
	POP	BC
;  597		
;  598		mos_fclose(file);
.LINE 598

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  599		return bmp;
.LINE 599

	LEA	HL,IX+%6
	LD	DE,(HL)
	LD	HL,IX
	LD	BC,-1117
	ADD	HL,BC
	LD	BC,1073
	LDIR	
	LD	HL,(IX+%6)
;  600		
;  601	}
L_166:
.LINE 601

	LD	SP,IX
	POP	IX
	RET	


;**************************** _load_bmp_clean ***************************
;Name                         Addr/Register   Size   Type
;_mos_fclose                         IMPORT  -----   function
;_mos_fgetc                          IMPORT  -----   function
;_free                               IMPORT  -----   function
;_mos_flseek                         IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;_mos_fread                          IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_mos_getfil                         IMPORT  -----   function
;_mos_fopen                          IMPORT  -----   function
;_memset                             IMPORT  -----   function
;bmp                                IX-1117   1073   variable
;initial_header                       IX-44     18   variable
;src                                  IX-26      3   variable
;r                                    IX-23      1   variable
;g                                    IX-22      1   variable
;b                                    IX-21      1   variable
;index                                IX-20      1   variable
;src                                  IX-19      3   variable
;fo                                   IX-16      3   variable
;y                                    IX-13      2   variable
;x                                    IX-11      2   variable
;row_rgba2222                          IX-9      3   variable
;y                                     IX-6      2   variable
;main_header                           IX-4      3   variable
;file                                  IX-1      1   variable
;slot                                 IX+12      1   parameter
;filename                              IX+9      3   parameter


; Stack Frame Size: 1150 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "load_bmp_clean",601,"_load_bmp_clean"
	SEGMENT STRSECT
L__102:
	DB	"Error: could not open "
	DB	0
L__103:
	DB	"."
	DB	13,10,0
L__109:
	DB	"Non standard BMP compression, exiting."
	DB	13,10,0
L__114:
	DB	"16-bit BMP files not supported, use 8-bit (small), 24-bit (fast) or 32-bit (alpha-enabled)."
	DB	13,10,0
L__119:
	DB	"16-bit BMP files not supported, use 8-bit (small), 24-bit (fast) or 32-bit (alpha-enabled)."
	DB	13,10,0
	SEGMENT CODE
;  602	
;  603	uint16_t strtou16(const char *str) {
_strtou16:
.DEFINE "_strtou16"

.VALUE _strtou16

.CLASS 2

.TYPE 77

.ENDEF

.BEGFUNC "strtou16",603,"_strtou16"

.LINE 603

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "result"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "digit"

.CLASS 65

.VALUE -4

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;  604	    uint16_t result = 0;
.LINE 604

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
;  605	    const uint16_t maxDiv10 = 6553;  // 65535 / 10
;  606	    const uint16_t maxMod10 = 5;     // 65535 % 10
;  607	
;  608	    while (*str == ' ' || *str == '\t' || *str == '\n') {
.LINE 608

	JR	L_170
L_171:
;  609	        str++;
.LINE 609

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  610	    }
L_170:
.LINE 610

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	Z,L_171
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	Z,L_171
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,10
	OR	A,A
	SBC	HL,BC
	JR	Z,L_171
;  611	
;  612	    while (*str >= '0' && *str <= '9') {
.LINE 612

	JR	L_178
L_179:
;  613	        uint16_t digit = *str - '0';
.LINE 613

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LEA	HL,IY+%FFFFFFD0
	LD	(IX+%FFFFFFFC),L
	LD	(IX+%FFFFFFFD),H
;  614	        if (result > maxDiv10 || (result == maxDiv10 && digit > maxMod10)) {
.LINE 614

	LD	BC,(IX+%FFFFFFFE)
	LD.LIS	HL,6553
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_175
	LD.LIS	BC,6553
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_176
	LD	BC,(IX+%FFFFFFFC)
	LD.LIS	HL,5
	OR	A,A
	SBC.SIS	HL,BC
	JR	NC,L_176
L_175:
;  615	            return 65535;
.LINE 615

	LD.LIS	HL,65535
	JR	L_182
;  616	        }
L_176:
.LINE 616

;  617	        result = result * 10 + digit;
.LINE 617

	LD.LIS	HL,10
	LD	BC,(IX+%FFFFFFFE)
	CALL	__smulu
	LD	BC,(IX+%FFFFFFFC)
	ADD.SIS	HL,BC
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;  618	        str++;
.LINE 618

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  619	    }
L_178:
.LINE 619

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,48
	OR	A,A
	SBC	HL,BC
	JP	M,L__140
	JP	PE,L_181
	JR	L__141
L__140:
	JP	PO,L_181
L__141:
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	JP	P,L__142
	JP	PE,L_179
	JR	L__143
L__142:
	JP	PO,L_179
L__143:
L_181:
;  620	
;  621	    return result;
.LINE 621

	LD	HL,(IX+%FFFFFFFE)
;  622	}
L_182:
.LINE 622

	LD	SP,IX
	POP	IX
	RET	


;**************************** _strtou16 ***************************
;Name                         Addr/Register   Size   Type
;digit                                 IX-4      2   variable
;result                                IX-2      2   variable
;str                                   IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "strtou16",622,"_strtou16"
;  623	
;  624	uint8_t strtou8(const char *str) {
_strtou8:
.DEFINE "_strtou8"

.VALUE _strtou8

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "strtou8",624,"_strtou8"

.LINE 624

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "result"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "digit"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;  625	    uint8_t result = 0;
.LINE 625

	LD	(IX+%FFFFFFFF),%0
;  626	    const uint8_t maxDiv10 = 255 / 10;
;  627	    const uint8_t maxMod10 = 255 % 10;
;  628	
;  629	    while (*str == ' ' || *str == '\t' || *str == '\n') {
.LINE 629

	JR	L_186
L_187:
;  630	        str++;
.LINE 630

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  631	    }
L_186:
.LINE 631

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	Z,L_187
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	Z,L_187
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,10
	OR	A,A
	SBC	HL,BC
	JR	Z,L_187
;  632	
;  633	    while (*str >= '0' && *str <= '9') {
.LINE 633

	JR	L_194
L_195:
;  634	        uint8_t digit = *str - '0';
.LINE 634

	LD	HL,(IX+%6)
	LD	A,(HL)
	SUB	A,%30
	LD	(IX+%FFFFFFFE),A
;  635	        if (result > maxDiv10 || (result == maxDiv10 && digit > maxMod10)) {
.LINE 635

	LD	A,%19
	CP	A,(IX+%FFFFFFFF)
	JR	C,L_191
	LD	A,(IX+%FFFFFFFF)
	CP	A,%19
	JR	NZ,L_192
	LD	A,%5
	CP	A,(IX+%FFFFFFFE)
	JR	NC,L_192
L_191:
;  636	            return 255;
.LINE 636

	LD	A,%FF
	JR	L_198
;  637	        }
L_192:
.LINE 637

;  638	        result = result * 10 + digit;
.LINE 638

	LD	B,%A
	LD	C,(IX+%FFFFFFFF)
	MLT	BC
	LD	A,C
	ADD	A,(IX+%FFFFFFFE)
	LD	(IX+%FFFFFFFF),A
;  639	        str++;
.LINE 639

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  640	    }
L_194:
.LINE 640

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,48
	OR	A,A
	SBC	HL,BC
	JP	M,L__153
	JP	PE,L_197
	JR	L__154
L__153:
	JP	PO,L_197
L__154:
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	JP	P,L__155
	JP	PE,L_195
	JR	L__156
L__155:
	JP	PO,L_195
L__156:
L_197:
;  641	
;  642	    return result;
.LINE 642

	LD	A,(IX+%FFFFFFFF)
;  643	}
L_198:
.LINE 643

	LD	SP,IX
	POP	IX
	RET	


;**************************** _strtou8 ***************************
;Name                         Addr/Register   Size   Type
;digit                                 IX-2      1   variable
;result                                IX-1      1   variable
;str                                   IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "strtou8",643,"_strtou8"
;  644	
;  645	uint24_t strtou24(const char *str) {
_strtou24:
.DEFINE "_strtou24"

.VALUE _strtou24

.CLASS 2

.TYPE 78

.ENDEF

.BEGFUNC "strtou24",645,"_strtou24"

.LINE 645

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "result"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

.DEFINE "digit"

.CLASS 65

.VALUE -8

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	DEC	SP
	DEC	SP
;  646	    uint32_t result = 0;
.LINE 646

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
;  647	    const uint32_t maxDiv10 = 1677721;
;  648	    const uint32_t maxMod10 = 5;
;  649	
;  650	    while (*str == ' ' || *str == '\t' || *str == '\n') {
.LINE 650

	JR	L_202
L_203:
;  651	        str++;
.LINE 651

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  652	    }
L_202:
.LINE 652

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	Z,L_203
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	Z,L_203
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,10
	OR	A,A
	SBC	HL,BC
	JR	Z,L_203
;  653		
;  654	    while (*str >= '0' && *str <= '9') {
.LINE 654

	JR	L_210
L_211:
;  655	        uint32_t digit = *str - '0';
.LINE 655

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	E,H
	LD	BC,48
	XOR	A,A
	CALL	__lsub
	LD	(IX+%FFFFFFF8),HL
	LD	(IX+%FFFFFFFB),E
;  656	        if (result > maxDiv10 || (result == maxDiv10 && digit > maxMod10)) {
.LINE 656

	LD	HL,1677721
	LD	E,%0
	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	CALL	__lcmpu
	JR	C,L_207
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,1677721
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_208
	LD	HL,5
	LD	E,%0
	LD	BC,(IX+%FFFFFFF8)
	LD	A,(IX+%FFFFFFFB)
	CALL	__lcmpu
	JR	NC,L_208
L_207:
;  657	            return 16777215;
.LINE 657

	LD	HL,16777215
	JR	L_214
;  658	        }
L_208:
.LINE 658

;  659	        result = result * 10 + digit;
.LINE 659

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,10
	XOR	A,A
	CALL	__lmulu
	LD	BC,(IX+%FFFFFFF8)
	LD	A,(IX+%FFFFFFFB)
	CALL	__ladd
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;  660	        str++;
.LINE 660

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  661	    }
L_210:
.LINE 661

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,48
	OR	A,A
	SBC	HL,BC
	JP	M,L__166
	JP	PE,L_213
	JR	L__167
L__166:
	JP	PO,L_213
L__167:
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	JP	P,L__168
	JP	PE,L_211
	JR	L__169
L__168:
	JP	PO,L_211
L__169:
L_213:
;  662	
;  663	    return result;
.LINE 663

	LD	HL,(IX+%FFFFFFFC)
;  664	}
L_214:
.LINE 664

	LD	SP,IX
	POP	IX
	RET	


;**************************** _strtou24 ***************************
;Name                         Addr/Register   Size   Type
;digit                                 IX-8      4   variable
;result                                IX-4      4   variable
;str                                   IX+6      3   parameter


; Stack Frame Size: 17 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "strtou24",664,"_strtou24"
;  665	
;  666	int main(int argc, char * argv[]) {
_main:
.DEFINE "_main"

.VALUE _main

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "main",666,"_main"

.LINE 666

.DEFINE "argc"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "argv"

.CLASS 65

.VALUE 9

.TYPE 290

.ENDEF

.DEFINE "bitmap_slot"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -7

.TYPE 14

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -13

.TYPE 14

.ENDEF

.DEFINE "bmp"

.CLASS 65

.VALUE -1086

.TAG "NONAME6"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-6452
	ADD	HL,SP
	LD	SP,HL
;  667	
;  668	    uint24_t x, y;
;  669		uint8_t bitmap_slot = 0;
.LINE 669

	LD	(IX+%FFFFFFFF),%0
;  670		bmp_info bmp;
;  671		
;  672		//Args = 0:binary name, 1:filname, 2:slot, 3:topleft, 3:topright
;  673		
;  674		if ((argc < 2) || (argc == 4) || (argc > 5)) {
.LINE 674

	LD	BC,2
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JP	M,L__184
	JP	PE,L_217
	JR	L__185
L__184:
	JP	PO,L_217
L__185:
	LD	BC,4
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_217
	LD	BC,(IX+%6)
	LD	HL,5
	OR	A,A
	SBC	HL,BC
	JP	P,L__186
	JP	PE,L_219
	JR	L__187
L__186:
	JP	PO,L_219
L__187:
L_217:
;  675	        // printf("Usage is %s <filename> [bitmap slot] [top-left x] [top-left y]\r\n", argv[0]);
;  676	        // return 0;
;  677			bmp = load_bmp_clean(argv[1], 0);
.LINE 677

	LD	BC,0
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	LD	HL,IX
	LD	BC,-2159
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_load_bmp_clean
	POP	BC
	POP	BC
	POP	BC
	LD	IY,IX
	LD	BC,-1086
	ADD	IY,BC
	LD	DE,IY
	LD	BC,1073
	LDIR	
;  678	    }
L_219:
.LINE 678

;  679		
;  680		if (argc > 2) bitmap_slot = strtou8(argv[2]);
.LINE 680

	LD	BC,(IX+%6)
	LD	HL,2
	OR	A,A
	SBC	HL,BC
	JP	P,L__188
	JP	PE,L_235
	JR	L__189
L__188:
	JP	PO,L_235
L__189:
	LD	IY,(IX+%9)
	LEA	HL,IY+%6
	LD	BC,(HL)
	PUSH	BC
	CALL	_strtou8
	POP	BC
	LD	(IX+%FFFFFFFF),A
L_235:
;  681		
;  682	    //vdp_mode(8);
;  683		
;  684		if (argc == 2) {
.LINE 684

	LD	BC,2
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_234
;  685			
;  686			bmp = load_bmp_clean(argv[1], 0);
.LINE 686

	LD	BC,0
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	LD	HL,IX
	LD	BC,-3232
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_load_bmp_clean
	POP	BC
	POP	BC
	POP	BC
	LD	IY,IX
	LD	BC,-1086
	ADD	IY,BC
	LD	DE,IY
	LD	BC,1073
	LDIR	
;  687			
;  688		} else if (argc == 3) {
.LINE 688

	JR	L_236
L_234:
	LD	BC,3
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_232
;  689			
;  690			if (strcmp(argv[2], "/i") == 0) get_info(argv[1]);
.LINE 690

	LD	BC,L__177
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%6
	LD	BC,(HL)
	PUSH	BC
	CALL	_strcmp
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_221
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	LD	HL,IX
	LD	BC,-4305
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_get_info
	POP	BC
	POP	BC
;  691			else bmp = load_bmp_clean(argv[1], bitmap_slot);
.LINE 691

	JR	L_236
L_221:
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	LD	HL,IX
	LD	BC,-5378
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_load_bmp_clean
	POP	BC
	POP	BC
	POP	BC
	LD	IY,IX
	LD	BC,-1086
	ADD	IY,BC
	LD	DE,IY
	LD	BC,1073
	LDIR	
;  692			
;  693		} else if (argc == 5) {
.LINE 693

	JR	L_236
L_232:
	LD	BC,5
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_236
;  694		
;  695			bmp = load_bmp_clean(argv[1], bitmap_slot);
.LINE 695

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	LD	HL,IX
	LD	BC,-6451
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_load_bmp_clean
	POP	BC
	POP	BC
	POP	BC
	LD	IY,IX
	LD	BC,-1086
	ADD	IY,BC
	LD	DE,IY
	LD	BC,1073
	LDIR	
;  696			
;  697			if (argv[3][0] == 'C' || argv[3][0] == 'c') x = (getsysvar_scrwidth() - bmp.bmp_width) / 2;
.LINE 697

	LD	IY,(IX+%9)
	LEA	IY,IY+%9
	LD	(IX+%FFFFFFF6),IY
	LD	HL,(IX+%FFFFFFF6)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,67
	OR	A,A
	SBC	HL,BC
	JR	Z,L_223
	LD	HL,(IX+%FFFFFFF6)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,99
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_224
L_223:
	PUSH	IY
	PUSH	BC
	LD	IY,-6452
	LD	BC,IX
	ADD	IY,BC
	LD	(IY),A
	POP	BC
	POP	IY
	CALL	_getsysvar_scrwidth
	PUSH	IY
	PUSH	BC
	LD	IY,-6452
	LD	BC,IX
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	POP	IY
	LD	BC,HL
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1086
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	LD	BC,2
	CALL	__idivs
	LD	(IX+%FFFFFFF9),HL
;  698			else x = strtou16(argv[4]);
.LINE 698

	JR	L_228
L_224:
	LD	IY,(IX+%9)
	LEA	HL,IY+%C
	LD	BC,(HL)
	PUSH	BC
	CALL	_strtou16
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	(IX+%FFFFFFF9),HL
L_228:
;  699			
;  700			if (argv[4][0] == 'C' || argv[4][0] == 'c') y = (getsysvar_scrheight() - bmp.bmp_height) / 2;
.LINE 700

	LD	IY,(IX+%9)
	LEA	IY,IY+%C
	LD	(IX+%FFFFFFFC),IY
	LD	HL,(IX+%FFFFFFFC)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,67
	OR	A,A
	SBC	HL,BC
	JR	Z,L_226
	LD	HL,(IX+%FFFFFFFC)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,99
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_227
L_226:
	PUSH	IY
	PUSH	BC
	LD	IY,-6452
	LD	BC,IX
	ADD	IY,BC
	LD	(IY),A
	POP	BC
	POP	IY
	CALL	_getsysvar_scrheight
	PUSH	IY
	PUSH	BC
	LD	IY,-6452
	LD	BC,IX
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	POP	IY
	LD	BC,HL
	CALL	__stoiu
	LD	DE,HL
	LD	HL,-1084
	LD	BC,IX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	LD	BC,2
	CALL	__idivs
	LD	(IX+%FFFFFFF3),HL
;  701			else y = strtou16(argv[4]);
.LINE 701

	JR	L_229
L_227:
	LD	HL,(IX+%FFFFFFFC)
	LD	BC,(HL)
	PUSH	BC
	CALL	_strtou16
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	(IX+%FFFFFFF3),HL
L_229:
;  702			
;  703			vdp_extended_select(bitmap_slot);
.LINE 703

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_vdp_extended_select
	POP	BC
;  704			vdp_bitmapDrawSelected(x,y);
.LINE 704

	LD	BC,(IX+%FFFFFFF3)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	CALL	_vdp_bitmapDrawSelected
	POP	BC
	POP	BC
;  705			
;  706		}
L_236:
.LINE 706

;  707	
;  708	    return 0;
.LINE 708

	OR	A,A
	SBC	HL,HL
.LINE 709

	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_vdp_bitmapDrawSelected             IMPORT  -----   function
;_getsysvar_scrheight                IMPORT  -----   function
;_getsysvar_scrwidth                 IMPORT  -----   function
;_strcmp                             IMPORT  -----   function
;bmp                                IX-1086   1073   variable
;y                                    IX-13      3   variable
;G_1                                  IX-10      3   variable
;x                                     IX-7      3   variable
;G_2                                   IX-4      3   variable
;bitmap_slot                           IX-1      1   variable
;argv                                  IX+9      3   parameter
;argc                                  IX+6      3   parameter


; Stack Frame Size: 6464 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "main",709,"_main"
	SEGMENT STRSECT
L__177:
	DB	"/i"
	DB	0
	XREF _write16bit:ROM
	XREF _vdp_bitmapDrawSelected:ROM
	XREF _mos_getfil:ROM
	XREF _mos_flseek:ROM
	XREF _mos_fread:ROM
	XREF _mos_fgetc:ROM
	XREF _mos_fclose:ROM
	XREF _mos_fopen:ROM
	XREF _getsysvar_scrheight:ROM
	XREF _getsysvar_scrwidth:ROM
	XREF _mos_puts:ROM
	XREF _waitvblank:ROM
	XREF _putch:ROM
	XREF _strcmp:ROM
	XREF _memset:ROM
	XREF _memcpy:ROM
	XREF _malloc:ROM
	XREF _free:ROM
	XREF __u_uitoa:ROM
	XREF __u_itoa:ROM
	XREF ___print_sendstring:ROM
	XREF ___print_xputch:ROM
	XREF ___print_uputch:ROM
	XREF ___print_fmt:ROM
	XREF __lcmpu:ROM
	XREF __ladd:ROM
	XREF __lsub:ROM
	XREF __idivs:ROM
	XREF __imuls:ROM
	XREF __lmulu:ROM
	XREF __smulu:ROM
	XREF __bshl:ROM
	XREF __irems:ROM
	XREF __ishrs:ROM
	XREF __stoi:ROM
	XREF __stoiu:ROM
	XREF __itol:ROM
	XREF __ildix:ROM
	XREF __istix:ROM
	XREF __ladd_b:ROM
	XREF __ishrs_b:ROM
	XDEF _main
	XDEF _strtou24
	XDEF _strtou8
	XDEF _strtou16
	XDEF _load_bmp_clean
	XDEF _get_info
	XDEF _print_bin
	XDEF _getByte
	XDEF _generic8888_to_rgba2222
	XDEF _bgra8888_to_rgba2222
	XDEF _bgr888_to_rgba2222
	XDEF _reorder_and_insert
	XDEF _reorder
	XDEF _assign_buffer_to_bitmap
	XDEF _vdp_extended_select
	XDEF _add_stream_to_buffer
	XDEF _select_buffer
	XDEF _clear_buffer
	XDEF _rgba8888_to_rgba2222
	XDEF _twiddle_buffer
	XDEF _flip
	XDEF _max
	XDEF _min
	XDEF _delay_secs
	END
